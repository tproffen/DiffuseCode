1  diffev

   The program is invoked by typing 'diffev' at the operating system or 
   at the shell prompt. The program uses a command language to interact 
   with the user. The command 'exit' or a CTRL Z terminates the program.

   More information about the syntax, expressions etc. of the command
   language can be obtained by typing 'command' at the help prompt.

   Help on the program is obtained by typing "help" or "help <command>" to
   get specific help on the command <command>. The command may be abbreviated.
   If the abbreviation is not unique, only the first help topic that matches
   the command is listed.

   The first line of the help text gives the syntax of the command that is
   explained in the following lines. For a few commands the syntax line is
   repeated for different set of possible parameters.

   Further help topics are:

2  News
3  2016_april

   The initialise command was augmented by a second form to  initialise
   just the logfiles, see ==> 'logfile', 'summary'.
   This might be helpful if you want to reset the refinent cycle
   to a smaller generation number. For very length refinements with 
   a few thousand refinement cycles and many parameters, a continuation
   will take appreciable time to read all previous cycles. If the
   actual development accross the cycles is not relevant to you you 
   can reduces the file sizes drastically be a sequence like:
   pop_gen[1] = 1
   initialise logfile

   New command 'lastfile'

   This new command creates a short copy of the ==> 'logfiles'. 
   This short form contains the parameters just for the last
   refinement generation.
   
2  Synopsis

!p Description ! A description of the program
!p News        ! Information on recent changes
!p allocate    ! Allocate array sizes
!p adapt       ! Adaption of global/local search width
!p backup      ! Backup current best solutions
!p compare     ! Compares the results of the current population
!p constraint  ! Defines a constraint condition
!p deallocate  ! Deallocate array sizes
!p dismiss     ! Dismiss the worst parents; replace by new children
!p donor       ! Defines which donor to use
!p fix         ! Fixes a parameter 
!p initialize  ! Initializes the generation zero
!p logfile     ! Defines the file name for the parameters for each generation
!p pop_name    ! Defines names for the individual parameters
!p refine      ! Defines which parameters are refined/fixed
!p restrial    ! Defines the file name for the current R-values
!p run_mpi     ! Run the cost function program in parallel through MPI
!p selection   ! Defines how children/parents survive into next generation
!p summary     ! Defines the file name for a summary of the parameter changes
!p trialfile   ! Defines the file name for the current parameters
!p type        ! Sets the numerical type for a parameter (integer or real)
!p write       ! Writes new Children or new GENERATION file
2  Description

   The program DIFFEV uses the differential evolution algorithm to refine
   a set of parameters to a set of observations.

   DIFFEV provides the handling of the parameters and their evolution. 
   An external program must be used to calculate the cost function or
   R-value that corresponds to a given set of parameters.

   The differential evolution algorithm compares simultaneously the resulting
   cost function for several sets of parameters. The number of parameter sets
   is called the population. For each member of the population a set of
   parameters is used. This is called a parameter vector. Its dimension
   depends on the model that you need to describe. In order to describe
   a parabola you would need three parameters. The whole set of parameters
   is called a generation.

   For each generation, the cost function is evaluated for each member of
   the population. The next generation is determined from the current
   parent generation through the following procedure:

   Loop over all members
     - Choose a member (at random or at will), this will be the 
       donor base.
     - Set a point along the line between current member and donor base
       to create the effective donor base ==> diff_k[1]
     - Select two other members by random choice
     - Loop over all parameters:
        - Take the difference between the corresponding parameters of the 
          two other randomly chosen members.
        - Multiply this difference by a user provided value ==> diff_f[1].
        - Add the difference vector to the effective donor base to 
          create a parameter set called the donor.
          - One parameter of the donor is always chosen for the child.
            All other parameters are then randomly chosen from:
            Either:  the parent 
            Or    :  the donor
          - The probability for this choice is weighted by a user provided
            probability ==> diff_cr[1].

   Once a new generation has been determined the corresponding cost function 
   is calculated. 

   Next the selection process determines, which current children survive 
   into the next generation. This is done either by:
   - Direct comparison between a parent member and its immediate child.
     Only those new members survive, whose cost function is
     less than that of the parent. Otherwise the parent is retained.
   - All parents and all children are pooled into one set. From this set
     the best members survive, irrespective whether they were a parent
     or a child.

   Such an algorithm is able to search for parameters if a standard refinement
   algorithm fails or is difficult to adapt. This might be the case for:
   - Undefined parameter values within the possible range. The parameter
     P may for example NOT be equal to 1 for a function: 1/(1-P) but values
     larger AND smaller are allowed.
   - The calculation of the cost function involves existing extensive 
     algorithms or several different programs.
   - The calculation involves the averaging of several calculations that
     rely on data created by (Gaussian-) randomly distributed parameters.

   Files

   DIFFEV uses several files to store the parameter values, the current
   status etc these are:

   "GENERATION"   Fixed file name in the current directory!

   The file "GENERATION" contains ten lines with the current generation
   number, and all relevant file names.

!p # generation members children parameters 
!p      158        45        90         4
!p # trial file
!p DIFFEV/Trials
!p # result file
!p DIFFEV/Results
!p # log file
!p DIFFEV/Parameter
!p # summary file
!p DIFFEV/Summary

   Trial files

   DIFFEV writes a short file for each member that contains the current
   parameters for one member. 
   The user defined filename is appended by a four digit member number.
   The first lines contain the information
   on current generation number, the number of members in the population,
   the number of children and the number of parameters
!p # generation members children parameters
!p      181        45        90         4
!p # current member
!p     1
!p # parameter list
!p     0.8284027688E-02
!p     0.5815573883E+02
!p     0.2050311089E+01
!p     0.3000000000E+01

   Result files

   DIFFEV expects to read the R-values for each member from a short file.
   The user defined filename is appended by a four digit member number.

   The file must contain the member number and the R-value in free format
   within the first line.

   Parameter files

   For the R-value and for each parameter a SPEC type file is written that
   contains all old R-values and parameters, respectively.
   Each generation makes up a scan. The first column is the member number, 
   the second column is the R-value and the third column is the respective 
   parameter value.
   The base name of the parameter files can be set by the user via command
   ==> 'logfile'. This base name is appended by a four digit number with
   leading zeros. Parameter file no 0000 has the same structure, except that
   both column two and three are the R-values.

   Last file

   A short copy of the parameter file that contains the parameters
   just for the last generation.

   Summary files

   For the R-value and for each parameter a SPEC type summary files 
   contains a single scan. Each generation creates one line within the
   scan. Five values arew written to each line. The first column is the
   generation number
   For the R-value and each of the parameters four further columns are
   written. The first of these is the average value, the second the 
   minium value, the third the maximum value and the fourth the sigma of
   the parameter distribution.
   The base name of the summary files can be set by the user via command
   ==> 'summary'. This base name is appended by a four digit number with
   leading zeros. Summary file no 0000 has the same structure, except that
   both column two and three are the R-values.

   Further help topics are:

3  Basic_Example

   This example illustrates the commands to refine the three parameters 
   that describe a parabola: y = P1*x**2 + P2*x + P3

   You will find the data and the macros in the diffev/Example directory
   within the program source directories.
!p ======================diffev.mac======================================
!p #
!p #
!p pop_gen[1]  = 0         # initialize the current generation to zero
!p #
!p pop_n[1]    = 15        # The population shall have 15 members
!p pop_c[1]    = 15        # The population shall have 15 children
!p pop_dimx[1] = 3         # We need three parameters
!p #
!p pop_name      1,square  # The parameter is called "square"
!p #
!p type          1,real    # Parameter 1 is a floating number
!p #
!p pop_xmin[1] = -1.0      # The first parameter is restricted to the
!p pop_xmax[1] =  1.0      # range -1 to +1
!p #
!p pop_smin[1] = -0.8      # The starting parameters of the first parameter
!p pop_smax[1] = +0.8      # are restricted to the range -0.8 to +0.8
!p #
!p pop_sig[1]  =  0.02     # The sigma of minimum parameter "noise". 
!p pop_lsig[1] =  0.002    # The sigma for local searches
!p #
!p adapt  sigma, 1, 0.025  # After generation 0 the value of pop_sig[1] 
!p #                       # is adjusted to 0.025*(largest parameter -
!p #                       #                       smallest parameter )
!p #
!p adapt lsigma, 1, 0.0025 # After generation 0 the value of pop_lsig[1]
!p #                       # is adjusted to 0.0025*(largest parameter -
!p #                       #                        smallest parameter )
!p #
!p pop_name      2,linear 
!p pop_xmin[2] = -2.0
!p pop_xmax[2] =  2.0
!p pop_smin[2] = -1.8
!p pop_smax[2] = +1.8
!p #
!p pop_name      3,constant 
!p pop_xmin[3] = -5.0
!p pop_xmax[3] =  5.0
!p pop_smin[3] = -4.8
!p pop_smax[3] = +4.8
!p #
!p constraint  p[1].lt.1.3 # Several constraint may be imposed on the
!p constraint  p[2]+p[3].gt.0.0
!p #                       # parameters. Here the first parameter must be
!p #                       # less than 1.3. In the second constraint condition,
!p #                       # The sum of the second and third parameter must be
!p #                       # greater than zero.
!p #
!p diff_cr[1]  = 0.9       # The cross over probability is 90%
!p diff_f[1]   = 0.81      # The difference vectors are multiplied by 0.81
!p diff_k[1]   = 1.0       # For diff_k = 1, the difference vector is added
!p #                       # to the donor, for diff_k = 0 to the parent.
!p diff_lo[1]  = 0.1       # In 10% of all cases, a member creates its child
!p #                       # not by diffev algorithm, but from a local Gaussian
!p #                       # distributed search.
!p #
!p trialfile  Trials       # The temporary file of the current parameter
!p #                       # values
!p restrial   Resultate    # The temporary files of the resulting cost 
!p #                       # function. Must be written by the slave program.
!p logfile    Parameter    # The log file for the parameters
!p summary    Summary      # A shorter log file 
!p #
!p init                    # Initializes diffev, Generation zero is written.
!p #
!p do i[1]=1,15            # A loop over 15 generations
!p   sys kuplot < kcompare.mac > /dev/null
!p #                       # diffev starts the kuplot program with input 
!p #                       # from file "kcompare.mac". This macro instructs
!p #                       # kuplot to read the 'trialfiles', to calculate the
!p #                       # cost function for each member and to write the
!p #                       # results into the 'restrial' files.
!p #
!p   compare               # diffev reads the 'restrial' files, compares the 
!p #                       # cost functions of children and parents and 
!p #                       # creates the next generation.
!p #
!p enddo                   # End of the loop
3  Increase_Dimension

   Here is an example for a macro that should be used to increase the 
   number of parameters to be refined:

!p variable integer, ipar           # just a nice variable name
!p pop_dimx[1]    = pop_dimx[1] + 1 # increase dimension
!p ipar           = pop_dimx[1]     # copy into variable
!p
!p pop_name         ipar,cube       # Define name etc for new parameter
!p pop_xmin[ipar] = -5.0
!p pop_xmax[ipar] =  5.0
!p pop_smin[ipar] = -4.8
!p pop_smax[ipar] = +4.8
!p type real,       ipar
!p refine           ipar            # Set refinement flag
!p init             ipar            # Initialize just this new parameter
!p dismiss          pop_n[1]/2      # Set R-value of half the population 
!p                                  # to a very high value, thus they will
!p                                  # be replaced in the next generation
   
3  Hints

   These are some hints regarding useful parameters. They are derived 
   from the authors experience and are to be carefully adopted.

   The population size MUST be at least 4!

   The population size should be at least about ten times as large as the
   number of parameters, twenty times will give you a good sampling of the 
   parameter space. A smaller population runs the risk of converging into
   a local minimum.

   The cross over probability ==>diff_cr[1] should be about 0.8 
    A smaller value (lets say around 0.3), seems to prevent convergence,
      While a small value prevents the special properties of the 
      differential algorithm to be applied at all. At diff_cr[1]=0, 
      all children would always be identical to their parents!

   The multiplier for the difference vector ==> diff_f[1] should be 
   around 0.8
      A small value prevents the children from being very different 
      from their parents, while a large value ~> 1.5(?) seems to 
      prevent convergence, since all children always jump too far away
      from their parents.

   selection mode
      If the dependency of the cost function/R-value on the parameters
      is (or seems to be) fairly straightforward, the convergence is 
      much faster if you choose the selection best,all scheme. By increasing
      the number of children in comparison to the parents, the selection
      pressure also increases and the algorithm will move faster into 
      the minimum. This will, however, also happen if you happen to be close
      to a local minimum, instead of the global minimum!

   I cannot give a hint regarding the number of generations required.
   This depends too much on the problem at hand, parameter correlation,
   the initial choice of parameters etc.
2  News
3  2013_May

   The run_mpi command has been augmented by a "socket" qualifyer, which 
   will cause DIFFEV to run the application program controlled via a
   socket. This should speed up the process on a multi-core/multi-cpu
   system.
3  2011_June

   The program is now a fully functional fortran2003 program.
   There are no changes that must be followed by the user, but important
   differences exist in the memory allocation. The internal arrays that hold 
   the population are now all allocated automatically, when you define the 
   number of parameters to be refined, the size of the population and the 
   constraint equations. Most of the time you will not have to bother with 
   these computational details. If you whish, you can allocate appropriate 
   array sizes, see ==> 'allocate', 'deallocate'.

   With this version, the program allows the user to change the population
   size and the number of parameters to be refined during a refinement cylce.

   If the number of parameters to be refined in increased during a cycle,
   the program will automatically write new child parameter sets and patch
   the logfile and summary file.

   See the entry ==> "Description" ==> "Increase_Dimension" for an example.
   
   Related to this new feature, the ==> "initialize" command now allows to
   (re-)initialise an individual parameter.
2  allocate
!b allocate
!b allocate "default"
!b allocate "constraint", <max_constr>
!b allocate "population", <max_members>, <max_parameters>
!b allocate "show"

   DIFFEV allows to to allocate memory for the arrays needed to store the
   population and the constraints. DIFFEV will dynamically allocate
   the population size, the number of refinement parameters and the 
   number of constraints. 
   Thus one often may not have to use this command.

   If previously allocated arrays are reallocated, DIFFEV tries to save
   the old values and you can continue to use these. If the new array
   sizes are smaller than the previous ones, this can obviously not be
   done. DIFFEV will perform the new allocation, but all old data are lost.
   A short warning will be printed.

!b allocate
!b allocate "show"

   Without parameter or with the parameter "show", the allocate command
   shows the current memory allocations.

!b allocate "default"
   Allocates all array sizes to default values.

!b allocate "constraint", <max_constr>

   Allocates the maximum number of constraints that DIFFEV shall handle.

!b allocate "population", <max_members>, <max_parameters>
   Allocate the maximum population size and the maximum number of 
   parameters that can be refined. 
2  adapt
!b adapt "sigma" ,<parameter_number>,[,{"yes"|"no"|<value>}]
!b adapt "lsigma",<parameter_number>,[,{"yes"|"no"|<value>}]

   DIFFEV uses to "sigmas" to handle special situations.

   The global sigma pop_sig[<i>] is used in the following two situations:
   - a new parameter falls outside the range allowed by pop_xmin[<i>] and
     pop_xmax[<i>]. In this case the new parameter is chosen by adding a
     Gaussian random distributed value with sigma pop_sig[<i>] next to the 
     respective boundary.
   - the difference between two parameters is zero. This will usually 
     occur for integer parameters only. In this case the new parameter is
     chosen by adding a Gaussian random distributed value with sigma 
     pop_sig[<i>] to the value of the effective donor.

   If sigma is allowed to adapt during the fit, its value is set to
   (maximum parameter value - minimum parameter value) * <value>
   Thus, as the population converges to a smaller parameter spread, sigma
   dynamically becomes smaller as well. 

   The adaptation can be set for each parameter <parameter_number>
   separately.

   The local sigma is used to modify a member not by differential evolution,
   but by a adding a local shift to the member. The local shift is a 
   Gaussian distributed random value with sigma = <lsigma>.
   Whether DIFFEV uses this mode, is determined  by the ==> variable 
   diff_lo[1]. This gives the probability, that a given member will be 
   modified by the local change instead of differential evolution.
2  backup
!b backup "NONE"
!b backup <input> [,<extension] , <output>

   This command allows you to back up the current best solutions.
   Diffev expects that the current trial solutions are called
   inputfile.????
   or 
   inputfile.????.extension
   where "????" is a four digit integer number with leading zeros.
   Note that the '.' before the number "????" and before the extension
   are mandatory parts of the filename. You need to ensure that your
   version of "kup.diffev.mac" adheres to this standard. 
   If the output file name includes a path, make sure that the output
   directory does exist. DIFFEV does not create the output directory.


   Examples
   backup CALC/calc, FINAL/final
   This form will back up the files 
         "CALC/calc.????" as "FINAL/final.????"
   backup TEMP/calc, tth, FINAL/final
   This form will back up the files 
         "TEMP/calc.????.tth" as "FINAL/final.????.tth"

   If multiple files need to be backed up, use the 'backup' command
   repeatedly:

   backup TEMP/calc, tth,    FINAL/final
   backup TEMP/calc, grcalc, FINAL/final
   These two lines will back up the files 
         "TEMP/calc.????.tth"    as "FINAL/final.????.tth"
         "TEMP/calc.????.grcalc" as "FINAL/final.????.grcalc"

   backup NONE
     Turns off the back up option

   The backup option is useful, if the calculation of the solutions
   takes a long time and involves random configurations. In these cases,
   the extra time required to copy the files may outway the time to
   calculates these again after the end of the refinement. 
   If the calculation involves random configurations, a repeated 
   calculation of the solutions on which the cost function depends 
   may not yield exactly the same result. With the backup option you
   ensure that you always have those backed up solutions correspond
   to the actual cost function values that DIFFEV used.

   If the calculation of the solutions is quick or if it does not 
   involve random configurations it is faster not to run the backup
   during the refinements. 
2  branch
!b branch kuplot [, "-macro" <macro_name> [ <par1> [ , <par2> ...]]]
!b branch discus [, "-macro" <macro_name> [ <par1> [ , <par2> ...]]]

   Active within the discus suite only!

   Branches to the "kuplot" or "discus" section.

   Within this section any standard KUPLOT command can be
   given. The behaviour of "kuplot" is essentially the same
   as in the stand alone version. Likewise for DISCUS.
  
   The main use will branch to KUPLOT while the discus section
   is run via run_mpi from a DIFFEV slave.

   Optionally the "-macro" qualifier instructs the suite to run the 
   macro <macro_name> (with its optional parameters) before the 
   interactive session is started.
2  compare
!b compare {"silent"}

   This is the main part of the differential evolution section.
   This command reads the current results that the slave program stored
   in files ==> 'restrial' and compares these to the results of the 
   parent generation. A new set of children is calculated according to 
   the differential evolution algorithm. The successful parents are 
   written to the file ==> 'logfile', which stores their respective cost 
   function, and the full parameter set. At the same time the short summary 
   file ==> 'summary' is appended with abbreviated information about the
   last generation.  The new children parameters are
   written to the temporary files ==> 'trialfile'. The current 
   generation is increased in file 'GENERATION'.

   If the optional "silent" qualifier is specified, DIFFEV will not read 
   the result files. Instead, DIFFEV must have received the current results
   by explicitly setting the values of child_val[*] for all children. 
   This option will work best if a binding of DIFFEV, DISCUS, and KUPLOT
   into a library with interface to a common calling program is used.
2  constraint
!b constraint <logical expression>

   The parameter range may be restricted by defining one or several constraint
   conditions. Each condition must be a valid logical expression. For 
   details of the syntax see the manual entry under ==> Command language.
   The parameters within the condition are referred to by p[<i>], where
   <i> is parameter number, 1 up to the dimension of the problem at hand.
   The dimension is fixed through parameter ==> 'pop_dimx', see the 
   variable entry.

   Example

!p constraint  p[1].gt.2   # The first parameter must be larger than 2
!p constraint  4.le. p[2]**2 + p[3]**2
!p                         # The sum of parameters 2 and 3 squared must be
!p                         #  equal or greater than 4.

   If a constraint equation is not met, DIFFEV will create a new parameter
   set. This process is repeated until a valid parameter set is found, or
   until DIFFEV has tried so for MAX_CONSTR_TRIAL times. In this latter
   case the program stops.  
2  deallocate
!b deallocate {"all" | "constraint" | "population"}

   This command allows to deallocate memory for the specified program
   segments. This helps to conserve memory, if program sections are no
   longer needed.

   This deallocation applies to memory that you allocated yourself
   and also to memory that DIFFEV has allocated automatically during
   runtime. As DIFFEV does not necessarily know, when you do not need
   the results of certain calculations any longer, it does not
   deallocate the automatically allocated memory sections unless you
   tell DIFFEV to do so.

!p "constraint"
      Free memory associated to the maximum number of constraints.

!p "population"
      Free memory associated to the population size and maximum number
      of refineable parameters.
2  dismiss
!b dismiss {<n> | "all" }

   Set the R-value of the worst <n> parents to a very high value.
   Thus <n> of the next children will definetly have a better R-value
   and replace these parents. 

   This command should be used after you changed the parameter dimension
   and initialised ==> 'init' some or all of the trial values. 
   Otherwise, many or eval all of the new children might not have
   a better R-value than their parents, and as a consequence the 
   (re-)initilization of the trial values may get lost.
2  donor
!b donor {"best" | "random"}

   The donor vector may be chosen in two different ways.
   "best" chooses the parent member that has the best parameter set.
   "random" chooses at random one of the parent vectors as donor vector.
   Two other parent vectors are always chosen at random to form the
   difference vector that is added to the donor vector.
   DIFFEV chooses the effective donor base along the straight line 
   from the current parent vector to the donor. The point along this
   line is determined by the value of "diff_k[1]" (==> variables).
   For diff_k[1] = 0  the effective donor is the parent vector, 
   for diff_k[1] = 1  the effective donor is the donor vector itself.
2  fix
!b fix <parameter_no>, {<value> | "best"}

   This command fixes the value of parameter <parameter_no> to 
   <value> for all members of the population. The ==> refine
   flag is turned of for this parameter. 
   If the second parameter is "best", the parameter is set to the
   corresponding value of the current member with the best R-value.
2  initialize
!b initialize [ <par_number1> [, <par_number2>]] [, "silent"]
!b initialise "logfile"

   This command initializes the differential evolution sequence. 

   Before using this command, you must have defined:
!p Number of parameters to be defined ==> 'pop_dimx'
!p Size of the parent population      ==> 'pop_n'
!p Size of the children population    ==> 'pop_c'
!p Boundaries for each parameter      ==> 'pop_xmin'
!p                                    ==> 'pop_xmax'
!p Starting intervals for parameters  ==> 'pop_smin'
!p                                    ==> 'pop_smax'
!p Sigmas for parameter adjustment    ==> 'pop_sig'
!p Local sigmas                       ==> 'pop_lsig'
!p Cross over probability             ==> 'diff_cr'
!p Fraction of the difference vector  ==> 'diff_f'
!p Point between parent an donor base ==> 'diff_k'
!p Local search probability           ==> 'diff_lo'


   Without the optional parameters, 'initialize' is used to start
   the generation zero.

   'Initialize' will use this information to generate the zero's generation.
   The file 'GENERATION' is set to generation zero, the population size
   and the number of parameters is written. 
   The files ==> 'logfile' and 'summary' are initialized. Old versions
   with the same name are overwritten!
   The starting parameter values are written to files ==> 'trialfile'
   After the header, each line contains a one parameter, 
   'pop_n' (i.e. the size of the population) lines are written.

   If you want to reinitialize one or several parameters, the
   'initialize' command may be used with the optional parameter(s).
   In this case 'initialize' will simply set the corresponding
   parameter, or parameter range from <par_number1> to <par_number2>
   to the range defined by the values of pop_smin[*] and pop_smax[*].
   A new set of children and the GENERATION file is written.

   If the last parameter is the string "silent", the trial files are
   note written to your disk. DIFFEV expects to be part of a suite 
   program and will transfer the trial parameters directly to the 
   slave program. See also ==> 'trialfile', 'run_mpi', 'compare'

   The second form of the command can be used to initialize just
   the logfiles, see ==> 'logfile', 'summary'.
   This might be helpful if you want to reset the refinent cycle
   to a smaller generation number. For very length refinements with 
   a few thousand refinement cycles and many parameters, a continuation
   will take appreciable time to read all previous cycles. If the
   actual development accross the cycles is not relevant to you you 
   can reduces the file sizes drastically be a sequence like:
   pop_gen[1] = 1
   initialise logfile
2  lastfile
!b lastfile <filename>

   This defines the short log file of the parameter evolution. 

   After each generation, the short lastfile <filename> is overwritten
   by the parameters of the current generation.

   It is a SPEC type file that contains all old R-values and parameters.
   Only this last generation makes up a scan. The first column is the 
   member number, the second the R-value and all further columns the 
   respective parameter values.
2  logfile
!b logfile <filename>

   This defines the log file of the parameter evolution. 

   After each generation, the logfile <filename> is appended by the 
   parameters of the current generation.

   It is a SPEC type file that contains all old R-values and parameters.
   Each generation makes up a scan. The first column is the member number, 
   the second the R-value and all further columns the respective parameter 
   values.
2  refine
!b refine {"all"|"none"|<number> [,<number>...]}

   This command allows you to set, which of the variables are refined.
   If you give the parameter number as negative number, the corresponding
   parameter is not refined.
2  summary
!b summary <filename>

   This defines the log file of the R-value/cost function evolution. 

   The SPEC type summary files contains a single scan. Each generation 
   creates one line within the scan. The first columns is the generation
   number. For the R-value and each of the parameters four columns are
   written. The first of these is the average value, the second the 
   minium value, the third the maximum value and the fourth the sigma of
   the parameter distribution.
2  restrial
!b restrial <result>

   These temporary files are used to communicate the R-value from the 
   slave program back to DIFFEV. 
   DIFFEV expects a separate file for each member of the population. 
   The filename <result> is automatically augmented by a four digit 
   member number. Thus, if the filename is Results, DIFFEV expects to 
   find the files:
!p Results.0001
!p Results.0002
!p etc.
   The file contains one line with two numbers, the member number and 
   the R-value obtained for the corresponding set of parameters in 
   file ==> 'trialfile'.

   If the file name is the string "silent", the result files are
   note read from your disk. DIFFEV expects to be part of a suite 
   program and will expect that the result values have been transfered
   directly from the slave program. See also ==> 'trialfile', 'run_mpi', 'compare'
2  run_mpi
!b run_mpi <program_name>, <macro_name>, <no_repetitions>, <output_base> [,"socket"]

   This command starts parallel processing of program <program_name>.
   The program will be executed <pop_c>*<no_repetitions> times.
   <pop_c> is the number of children for the current refinement and 
   each child corresponds to one ==> trialfile. 
   The calculations can be repeated <no_repetions> times, with the identical 
   parameter set. This may be necessary, if you need to average several
   calculations.
   The standard output of the program will be directed into a file
   <output_base>. The current child number ( and the current repeat
   number, if present) will be appended as four digit wide field.
   On a UNIX system you can redirect the output to /dev/null.

   If the last optional parameter is "socket", the program will be
   started via a socket connection, else via a single "system" call.

   system == non-socket option:

   The actual line that starts the program has syntax:
   "program_name" -macro <macro.name> <cwd> <child> <indiv> > <output>

   <macro_name> name of the macro file to be executed
   <cwd>        1st macro parameter string with current directory
   <child>      current child number (1 to pop_c)
   <indiv>      current repetion number (1 to <no_repetions>)
                This parameter is omitted, if <no_repetions> is zero
   <output>     File for standard output written by <program_name>

   Example
   run_mpi discus, discus.mac, 5, LOGFILES/d
           Runs discus with macro "discus.mac". For each child the 
           calculation is repeated 5 times. DISCUS output is written
           into files "LOGFILES/d.xxxx.yyyy", where "xxxx" is the 
           child number and "yyyy" the repetion number.
   run_mpi discus, discus.mac, 5, /dev/null
           Same, except that the output is written to "/dev/null" 
           i.e. it is thrown away.
   run_mpi discus, discus.mac, 0, LOGFILES/d
           Same, except that no repetions are requested. Only one
           calculation is performed per child and the output is
           written to "LOGFILES/d.xxxx". 

   socket option:

   The program is startet via socket at the beginning of a refinement. It
   remains active until diffev is terminated. A second, third program may
   be started as well, such as a discus run followed by kuplot.

   The socket option starts the program via the line:
   
   "program_name" -remote -access=127.0.0.0 -port=<port> > <output>

   Thereafter the vatiables generation, member, children, parameters,
   kid, indiv, nindiv are defined and placed at their proper values.
   The corresponding lines are 
   variable integer,generation
   generation = <value>
   And so on for the other variables.
   For each calculation i.e. combination of kid, indiv the current 
   values are sent for "kid" and "indiv". All corresponding trial 
   values are placed into the array "r[*]", into entries 201 to
   201 + <parameters>. Then the calculation macro is started, which
   does of course not have to read the GENERATION and the trial file.
2  selection
!b selection {"compare" | "best","all"}

   This command governs the selection criterium that determines which 
   children and parents survive into the next generation.

!p "compare"    Each child is compared to its immediate parent. The better
!p              of these two will survive into the next generation. It will
!p              serve as one of the parents from which the next children 
!p              are derived using the Differential Evolution Algorithm.
!p              The number of children ==> 'variables' pop_c, should be 
!p              identical to the number of members i.e. parents
!p              ==> 'variables' pop_n.
!p "best","all" All parents and all children are put into a single list.
!p              Of this list the best <pop_n[1]> members survive into 
!p              the next generation. No restriction applies to keep any
!p              parent or any children. 
!p              You are free to use any number of children. If the number of 
!p              children is increased compared to the number of parents, the
!p              selection becomes "tougher" since a smaller percentage of the
!p              whole population survives into the next generation. This will
!p              speed up convergence, yet run a higher risk of getting stuck
!p              in a local minimum.
2  trialfile
!b trialfile <filename>|"silent"

   These temporary files are used to communicate the current set of parameters
   between DIFFEV and the slave program. 

   DIFFEV writes a separate file for each member of the population. 
   The filename <filename> is automatically augmented by a four digit 
   member number. The if the filename is Trials, DIFFEV expects to 
   find the files:
!p Trials.0001
!p Trials.0002
!p etc.

   The file has format:

!p # generation members children parameters
!p      181        45        90         4
!p # current member
!p     1
!p # parameter list
!p     0.8284027688E-02
!p     0.5815573883E+02
!p     0.2050311089E+01
!p     0.3000000000E+01

   The first states the current generation, the number of members in 
   the population, the number of children in each population, and the 
   number of parameters. 
   The next two lines states the number of the current member. 
   This is followed by a list of all parameter values, each in a separate
   line.

   If the file name is the string "silent", the trial files are
   note written to your disk. DIFFEV expects to be part of a suite 
   program and will transfer the trial parameters directly to the 
   slave program. See also ==> 'trialfile', 'run_mpi', 'compare'
2  type
!b type {"integer" | "real"},<number>

   Defines the number that the parameter <number> assumes. Valid options
   are:
!p "integer" The parameter is restricted to integer numbers.
!p "real"    The parameter may take on any real,floating number.

   See the entry on 'variables' regarding options to limit the allowed range,
   and the entry ==> 'constraint' on possible constraints.
2  variables

   Like all programs of the Diffuse suite, diffev offers integer and
   real variable for standard calculations == Command Language/variables

   Unique diffev variables are:

!p pop_gen[1]    The number of the current generation
!p pop_n[1]      The size of the parent population
!p               The size of the population may be changed during a
!p               refinement. In this case the GENERATION file is updated
!p               automatically. If the population is increased, the R-values
!p               for the new members are set to ten times the maximum 
!p               current R-value. Parameter values are copied from old 
!p               member no. one.
!p pop_c[1]      The size of the children population
!p               The size of the children population may be changed during a
!p               refinement. In this case, a new set of trial files is 
!p               automatically generated and the GENERATION file is updated
!p               as well.
!p pop_dimx[1]   The dimension, i.e. the number of parameters
!p               The dimension may be increased during a refinement. To do 
!p               so you need to increase pop_dimx[1], set all parameter
!p               related values for tis new parameter and run the 
!p               ==> 'init <par_number>' command. This will initialize the
!p               parameter to the starting range and update the trial files
!p               and the generation file.
!p
!p pop_xmin[<i>] Minimum allowed value for parameter <i>
!p pop_xmax[<i>] Maximum allowed value for parameter <i>
!p
!p pop_smin[<i>] Minimum starting value for parameter <i>
!p pop_smax[<i>] Maximum starting value for parameter <i>
!p
!p pop_sig[<i>]  Sigma of Gaussian distribution for parameter <i>. If the
!p               difference between two parent parameters is zero, or if a
!p               child parameter is outside the limits defined by pop_xmin
!p               and pop_xmax, the corresponding parameter is modified by
!p               a Gaussian distributed random number. 
!p               Set pop_sig to zero to switch off this option.
!p
!p pop_lsig[<i>] Sigma of local Gaussian distribution for parameter <i>. 
!p               The probability diff_lo[1] determines if a given member
!p               is changed locally only or takes part in the usual 
!p               differential evolution algorithm. If it is changed only
!p               locally, the parent parameters are modified by adding
!p               a Gaussian distributed random number, with mean zero 
!p               and sigma pop_lsig.
!p
!p pop_v[<i>,<j>] Value of parameter <i> for member <j>
!p               This parameter is read only.
!p
!p pop_t[<i>,<j>] Current trial value of parameter <i> for child <j>
!p
!p rvalue[<i>]   R-value for member <j>. This is the R-value for the 
!p               current parent generation.
!p
!p bestm[1]      Parent member that currently has the lowest R-value
!p
!p bestr[1]      Currently lowest R-value.
!p
!p worstm[1]     Parent member that currently has the highest R-value
!p
!p worstr[1]     Currently highest R-value.
!p
!p p[<i>]        Parameter symbol used in the constraint conditions.
!p
!p diff_cr[1]    Cross over probability
!p diff_f[1]     Multiplier for difference vector
!p diff_k[1]     Multiplier for vector between parent vector and donor
!p diff_lo[1]    Probability for local refinement of a population member
!p diff_sel[1]   Selection mode for compare command, READ_ONLY
2  write
!b write {"children" | "generation"}

!b write "children"
   The write command will generate a new set of child values and update
   the corresponding trial files and the GENERATION file. The generation
   number is not changed.

!b write "generation"
   Writes the GENERATION file. No changes are done to the file.
