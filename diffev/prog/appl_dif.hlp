1  diffev

   The program is invoked by typing 'diffev' at the operating system or 
   at the shell prompt. The program uses a command language to interact 
   with the user. The command 'exit' or a CTRL Z terminates the program.

   More information about the syntax, expressions etc. of the command
   language can be obtained by typing 'command' at the help prompt.

   Help on the program is obtained by typing "help" or "help <command>" to
   get specific help on the command <command>. The command may be abbreviated.
   If the abbreviation is not unique, only the first help topic that matches
   the command is listed.

   The first line of the help text gives the syntax of the command that is
   explained in the following lines. For a few commands the syntax line is
   repeated for different set of possible parameters.

   Further help topics are:

2  News
3  2019_Jun

   If a slave process terminates with an error message, a new macro
   is written that is essentially identical to "diffev_best.mac".
   This macro called "diffev_error.NNNN.NNNN.mac", where "NNNN.NNNN"
   are the REF_KID and REF_INDIV number of the slave process that failed.
   If this macro is run in a regular DISCUS_SUITE session it will 
   recreate the error with exactly the same parameters and random numbers 
   as the failed slave. 

   A bug was fixed in the handling of the random state for
   "diffev_best.mac". The random state is now recorded exaclty.
3  2019_Jan

   Improved the writing of the diffev_best.mac macro. 
   The state of "compute:" is evaluated and multiple "run_mpi" lines
   are taken into account.
3  2018_Nov

   Added a new command 'restart <user_generation>' This command compares
   the user value to the current value in GENERATION. If the user
   value is smaller, the Logfiles, Summary and Last files are 
   shortened and the GENERATION file is adapted. This lets you step 
   back to an earlier refinement status. Keep in mind that the later
   cycles are irrevocably lost. If in doubt make a backup first.

   reinstated the ==> 'read' command

   Added further options to the ==> 'release' command
3  2018_Oct

   Added a ==> 'release' command that is intended to act
   complementary to a previopus ==> 'fix' command.
3  2018_July

   A small modification to the "diffev_best" macro. 
   The value of REF_NINDIV is written and at the end a
   "set error, continue' instruction has been added.
3  2018_June

   Revised the reaction to a CTRL-C

   Added a ==> 'set error, ... , "save" option

   Revised the internal workings of the distribution within
   run_mpi. This has no effects on the user. It should enable you,
   however, to distribute the children much better on a system with
   many nodes and many CPU's per node. See the manual for further info.
3  2018_Feb

   Added an optional parameter "partial:<value>" to the 
   ==> 'restrial' command. This parameter tells DIFFEV how many
   partial R-values the slave program will calculate and return. 
   If set or if the value is larger than 1, DIFFEV will create
   logfiles "Summary.Rvalue.0001", "Parameter.Rvalue.0001" and
   "Current.Rvalue.0001" etc. for each partial R-value. 
   Use the KUPLOT commands 'rval' and 'cost' to set the 
   individual R-values and a (weighted) average.
   You can display the development of the partial R-values within
   KUPLOT" with the kuplot command 'kpara'.

   removed 'read' command
3  2018_Jan

   The logical comparisons may now take the operators:
   <, <=, ==, /=, >=, >/
   The classical fortran77 operators are still valid

   New logical functions "isvar" and "isexp" can be used within an
   "if" construction. See help entry ==>'function' in the
   general "Command_lang" section

   The ==> function par_number(<char_variable>) returns the 
   number for the refinement parameter in the character variable
   <char_variable>.

   The ==> function par_name(<number>) returns the name of the 
   refinement parameter number <i>.

   Finished the transformation from parameter numbers to 
   parameter names. All Log files now have an extension of the
   parameter name instead the parameter number.

   The new command ==>'reset' can be used to reset DIFFEV to the 
   conditions at program start. 
3  2018_Dec

   Major revision of the refinement parameter handling. 
   The new command 'newparam' effectively replaces for most of the 
   common refinements the need of the individual commands to set the 
   parameter values. Throughout the command language much more 
   emphasis is placed on the parameter names instead of the
   parameter numbers. See ==>'refine' and 'init' commands. 
   The parameter names are also placed into the user variable
   environment and handed down to the slave program (discus or kuplot)
   where they will have the appropriate values for the members of
   the population.

   Added a 'read' command that reads GENERATION and the ==> 'logfile'
   This allows for easier changes of the population size, see the
   entry 'Description / Population_size'
3  2017_Sep

   Throughout the program the internal calculation of random numbers 
   was changed to the FORTRAN 90 intrinsic function. 
3  2017_July
   DIFFEV has been modified to log the status of the random number generator 
   at the beginning of each slave calculation. This status is documented 
   internally for the current best member of the population. Once an 'exit'
   command is executed, DIFFEV will write a macro called "diffev_best.mac" 
   that can be used to recreate the current best solution.
3  2017_Jan
   An unfortunate typing error in News/2016_Oct regarding the new
   refinement variable 
   ref_para[1...]   ( was misspelled as ref_param[1...] )
   is corrected in the  on-line help.

   Another typing error caused an error in the macro parameters 
   transferred with a NON MPI command: run_mpi, making these 
   not backward compatible. This has been fixed.
3  2016_Dec

   At a few select points colors are introduced into the output.
   Currently these are just the error messages.

3  2016_Oct

   Global variables have been introduced that use the same syntax as
   user defined variables. This include just "pi" and variables related
   to the refinement.
   DIFFEV sets the value to these variables:
   REF_GENERATION  Current generation
   REF_MEMBER      Current population size
   REF_CHILDREN    Current children size
   REF_DIMENSION   Number of parameters 
   REF_KID         Current child Updated for DISCUS and KUPLOT only
   REF_INDIV       Current individuum Updated for DISCUS and KUPLOT only
   REF_NINDIV      Number of individual repetitions
   ref_para[1..]   Current trial parameters for current child
3  2016_june

   DIFFEV may now be interupted gracefully with a CTRL-c.
   This will cause DIFFEV to shut down MPI if active.

   The 'run_mpi' command can now be used as a generic interface to identical
   slave macros, regardless of the MPI status. 
3  2016_april

   The 'initialise' command was augmented by a second form to initialize
   just the logfiles, see ==> 'logfile', 'summary'.
   This might be helpful if you want to reset the refinement cycle
   to a smaller generation number. For very lengthy refinements with 
   a few thousand refinement cycles and many parameters, a continuation
   will take appreciable time to read all previous cycles. If the
   actual development across the cycles is not relevant to you you 
   can reduces the file sizes drastically be a sequence like:
   pop_gen[1] = 1
   initialise logfile

   New command 'lastfile'

   This new command creates a short copy of the ==> 'logfiles'. 
   This short form contains the parameters just for the last
   refinement generation.
3  2013_May

   The run_mpi command has been augmented by a "socket" qualifier, which 
   will cause DIFFEV to run the application program controlled via a
   socket. This should speed up the process on a multi-core/multi-cpu
   system.
3  2011_June

   The program is now a fully functional fortran2003 program.
   There are no changes that must be followed by the user, but important
   differences exist in the memory allocation. The internal arrays that hold 
   the population are now all allocated automatically, when you define the 
   number of parameters to be refined, the size of the population and the 
   constraint equations. Most of the time you will not have to bother with 
   these computational details. If you wish, you can allocate appropriate 
   array sizes, see ==> 'allocate', 'deallocate'.

   With this version, the program allows the user to change the population
   size and the number of parameters to be refined during a refinement cycle.

   If the number of parameters to be refined in increased during a cycle,
   the program will automatically write new child parameter sets and patch
   the logfile and summary file.

   See the entry ==> "Description" ==> "Increase_Dimension" for an example.
   
   Related to this new feature, the ==> "initialise" command now allows to
   (re-)initialize an individual parameter.
   
2  Synopsis

!p Description ! A description of the program
!p News        ! Information on recent changes
!p allocate    ! Allocate array sizes
!p adapt       ! Adaption of global/local search width
!p backup      ! Backup current best solutions
!p compare     ! Compares the results of the current population
!p constraint  ! Defines a constraint condition
!p deallocate  ! Deallocate array sizes
!p dismiss     ! Dismiss the worst parents; replace by new children
!p donor       ! Defines which donor to use
!p fix         ! Fixes a parameter 
!p initialize  ! Initializes the generation zero
!p lastfile    ! Defines a file name for the parameters for the last generation
!p logfile     ! Defines the file name for the parameters for each generation
!p newparam    ! Defines Ra new parameter or new values for a parameter
!p pop_name    ! Defines names for the individual parameters
!p refine      ! Defines which parameters are refined/fixed
!p release     ! Initialize a parameter that had been fixed
!p restrial    ! Defines the file name for the current R-values
!p run_mpi     ! Run the cost function program in parallel through MPI
!p selection   ! Defines how children/parents survive into next generation
!p summary     ! Defines the file name for a summary of the parameter changes
!p trialfile   ! Defines the file name for the current parameters
!p type        ! Sets the numerical type for a parameter (integer or real)
!p write       ! Writes new Children or new GENERATION file
2  Description

   The program DIFFEV uses the differential evolution algorithm to refine
   a set of parameters to a set of observations.

   DIFFEV provides the handling of the parameters and their evolution. 
   An external program must be used to calculate the cost function or
   R-value that corresponds to a given set of parameters.

   The differential evolution algorithm compares simultaneously the resulting
   cost function for several sets of parameters. The number of parameter sets
   is called the population. For each member of the population a set of
   parameters is used. This is called a parameter vector. Its dimension
   depends on the model that you need to describe. In order to describe
   a parabola you would need three parameters. The whole set of parameters
   is called a generation.

   For each generation, the cost function is evaluated for each member of
   the population. The next generation is determined from the current
   parent generation through the following procedure:

   Loop over all members
     - Choose a member (at random or at will), this will be the 
       donor base.
     - Set a point along the line between current member and donor base
       to create the effective donor base ==> diff_k[1]
     - Select two other members by random choice
     - Loop over all parameters:
        - Take the difference between the corresponding parameters of the 
          two other randomly chosen members.
        - Multiply this difference by a user provided value ==> diff_f[1].
        - Add the difference vector to the effective donor base to 
          create a parameter set called the donor.
          - One parameter of the donor is always chosen for the child.
            All other parameters are then randomly chosen from:
            Either:  the parent 
            Or    :  the donor
          - The probability for this choice is weighted by a user provided
            probability ==> diff_cr[1].

   Once a new generation has been determined the corresponding cost function 
   is calculated. 

   Next the selection process determines, which current children survive 
   into the next generation. This is done either by:
   - Direct comparison between a parent member and its immediate child.
     Only those new members survive, whose cost function is
     less than that of the parent. Otherwise the parent is retained.
   - All parents and all children are pooled into one set. From this set
     the best members survive, irrespective whether they were a parent
     or a child.

   Such an algorithm is able to search for parameters if a standard refinement
   algorithm fails or is difficult to adapt. This might be the case for:
   - Undefined parameter values within the possible range. The parameter
     P may for example NOT be equal to 1 for a function: 1/(1-P) but values
     larger AND smaller are allowed.
   - The calculation of the cost function involves existing extensive 
     algorithms or several different programs.
   - The calculation involves the averaging of several calculations that
     rely on data created by (Gaussian-) randomly distributed parameters.

   Files

   DIFFEV uses several files to store the parameter values, the current
   status etc these are:

   "GENERATION"   Fixed file name in the current directory!

   The file "GENERATION" contains twelve fixed lines with the current
   generation number, and all relevant file names.
   Further lines contain the backup file names if defined, the random
   number seeds and the finally the parameter names and their allowed
   numerical ranges.

!p  # generation members children parameters 
!p       158        45        90         4
!p  # trial file
!p  DIFFEV/Trials
!p  # result file
!p  DIFFEV/Results
!p  # log file
!p  DIFFEV/Parameter
!p  # summary file
!p  DIFFEV/Summary
!p  # last    file
!p  DIFFEV/Current


   Trial files (obsolete)

   DIFFEV writes a short file for each member that contains the current
   parameters for one member. 
   The user defined filename is appended by a four digit member number.
   The first lines contain the information
   on current generation number, the number of members in the population,
   the number of children and the number of parameters
!p # generation members children parameters
!p      181        45        90         4
!p # current member
!p     1
!p # parameter list
!p     0.8284027688E-02
!p     0.5815573883E+02
!p     0.2050311089E+01
!p     0.3000000000E+01

   Result files (obsolete)

   DIFFEV expects to read the R-values for each member from a short file.
   The user defined filename is appended by a four digit member number.

   The file must contain the member number and the R-value in free format
   within the first line.

   Parameter files

   For the R-value and for each parameter a SPEC type file is written that
   contains all old R-values and parameters, respectively.
   Each generation makes up a scan. The first column is the member number, 
   the second column is the R-value and the third column is the respective 
   parameter value.
   The base name of the parameter files can be set by the user via command
   ==> 'logfile'. As of Version 5.16.1 the base name is appended by an
   extension that is identical to the parameter name. Parameter file
   <name>.Rvalue has the same structure, except that both column two and
   three are the R-values.

   Prior to version 5.16.1 the base name was appended by a four digit 
   number with leading zeros. Parameter file no 0000 has the same 
   structure, except that both column two and three are the R-values.

   Last file

   A short copy of the parameter file that contains the parameters
   just for the last generation.

   Summary files

   For the R-value and for each parameter a SPEC type summary files 
   contains a single scan. Each generation creates one line within the
   scan. Five values are written to each line. The first column is the
   generation number
   For the R-value and each of the parameters four further columns are
   written. The first of these is the average value, the second the 
   minimum value, the third the maximum value and the fourth the sigma of
   the parameter distribution.
   The base name of the summary files can be set by the user via command
   ==> 'summary'. This base name is appended by a four digit number with
   leading zeros. Summary file no 0000 has the same structure, except that
   both column two and three are the R-values.

   Further help topics are:

3  Basic_Example

   This example illustrates the commands to refine the three parameters 
   that describe a parabola: y = P1*x**2 + P2*x + P3

   You will find the data and the macros in the diffev/Example directory
   within the program source directories.
!p ======================diffev.mac======================================
!p #
!p #
!p pop_gen[1]  = 0         # initialize the current generation to zero
!p #
!p pop_n[1]    = 15        # The population shall have 15 members
!p pop_c[1]    = 15        # The population shall have 15 children
!p pop_dimx[1] = 3         # We need three parameters
!p #
!p pop_name      1,square  # The parameter is called "square"
!p #
!p type          1,real    # Parameter 1 is a floating number
!p #
!p pop_xmin[1] = -1.0      # The first parameter is restricted to the
!p pop_xmax[1] =  1.0      # range -1 to +1
!p #
!p pop_smin[1] = -0.8      # The starting parameters of the first parameter
!p pop_smax[1] = +0.8      # are restricted to the range -0.8 to +0.8
!p #
!p pop_sig[1]  =  0.02     # The sigma of minimum parameter "noise". 
!p pop_lsig[1] =  0.002    # The sigma for local searches
!p #
!p adapt  sigma, 1, 0.025  # After generation 0 the value of pop_sig[1] 
!p #                       # is adjusted to 0.025*(largest parameter -
!p #                       #                       smallest parameter )
!p #
!p adapt lsigma, 1, 0.0025 # After generation 0 the value of pop_lsig[1]
!p #                       # is adjusted to 0.0025*(largest parameter -
!p #                       #                        smallest parameter )
!p #
!p pop_name      2,linear 
!p pop_xmin[2] = -2.0
!p pop_xmax[2] =  2.0
!p pop_smin[2] = -1.8
!p pop_smax[2] = +1.8
!p #
!p pop_name      3,constant 
!p pop_xmin[3] = -5.0
!p pop_xmax[3] =  5.0
!p pop_smin[3] = -4.8
!p pop_smax[3] = +4.8
!p #
!p constraint  p[1].lt.1.3 # Several constraint may be imposed on the
!p constraint  p[2]+p[3].gt.0.0
!p #                       # parameters. Here the first parameter must be
!p #                       # less than 1.3. In the second constraint condition,
!p #                       # The sum of the second and third parameter must be
!p #                       # greater than zero.
!p #
!p diff_cr[1]  = 0.9       # The cross over probability is 90%
!p diff_f[1]   = 0.81      # The difference vectors are multiplied by 0.81
!p diff_k[1]   = 1.0       # For diff_k = 1, the difference vector is added
!p #                       # to the donor, for diff_k = 0 to the parent.
!p diff_lo[1]  = 0.1       # In 10% of all cases, a member creates its child
!p #                       # not by diffev algorithm, but from a local Gaussian
!p #                       # distributed search.
!p #
!p trialfile  silent       # Instead of writing to a file DIFFEV will pass the 
!p #                       # values silently down to DISCUS/KUPLOT
!p restrial   silent       # Instead of reading a resultfile, DIFFEV will
!p #                       # obtain the cost function results directly from
!p #                       # the slave program.
!p logfile    Parameter    # The log file for the parameters
!p summary    Summary      # A shorter log file 
!p #
!p init       silent       # Initializes diffev, Generation zero is written.
!p #
!p do i[1]=1,15            # A loop over 15 generations
!p   run_mpi kuplot, kcompare.mac, 0,  /dev/null
!p #                       # diffev starts the kuplot program with input 
!p #                       # from file "kcompare.mac". This macro instructs
!p #                       # kuplot to read the 'trialfiles', to calculate the
!p #                       # cost function for each member and to write the
!p #                       # results into the 'restrial' files.
!p #
!p   compare  silent       # diffev reads the 'restrial' files, compares the 
!p #                       # cost functions of children and parents and 
!p #                       # creates the next generation.
!p #
!p enddo                   # End of the loop
3  Increase_Dimension

   Here is an example for a macro that should be used to increase the 
   number of parameters to be refined:

!p newparam cube, -5.0, 5.0, -4.8, 4.8, keep:initialize
!p #                                # Defines a new parameter called "cube"
!p #                                # that is allowed to be in 
!p #                                # the range [-5:+5]
!p #                                # It is initialized in the
!p #                                # range [-4.8:+4.8]
!p dismiss          pop_n[1]/2      # Set R-value of half the population 
!p                                  # to a very high value, thus they will
!p                                  # be replaced in the next generation

   Prior to version 5.19 the macro would have taken the following command:

!p variable integer, ipar           # just a nice variable name
!p pop_dimx[1]    = pop_dimx[1] + 1 # increase dimension
!p ipar           = pop_dimx[1]     # copy into variable
!p
!p pop_name         ipar,cube       # Define name etc for new parameter
!p pop_xmin[ipar] = -5.0
!p pop_xmax[ipar] =  5.0
!p pop_smin[ipar] = -4.8
!p pop_smax[ipar] = +4.8
!p type real,       ipar
!p refine           ipar            # Set refinement flag
!p init             ipar            # Initialize just this new parameter
!p dismiss          pop_n[1]/2      # Set R-value of half the population 
!p                                  # to a very high value, thus they will
!p                                  # be replaced in the next generation
   
3  Hints

   These are some hints regarding useful parameters. They are derived 
   from the authors experience and are to be carefully adopted.

   The population size MUST be at least 4!

   The population size should be at least about ten times as large as the
   number of parameters, twenty times will give you a good sampling of the 
   parameter space. A smaller population runs the risk of converging into
   a local minimum.

   The cross over probability ==>diff_cr[1] should be about 0.8 
    A smaller value (lets say around 0.3), seems to prevent convergence,
      While a small value prevents the special properties of the 
      differential algorithm to be applied at all. At diff_cr[1]=0, 
      all children would always be identical to their parents!

   The multiplier for the difference vector ==> diff_f[1] should be 
   around 0.8
      A small value prevents the children from being very different 
      from their parents, while a large value ~> 1.5(?) seems to 
      prevent convergence, since all children always jump too far away
      from their parents.

   selection mode
      If the dependency of the cost function/R-value on the parameters
      is (or seems to be) fairly straightforward, the convergence is 
      much faster if you choose the selection best,all scheme. By increasing
      the number of children in comparison to the parents, the selection
      pressure also increases and the algorithm will move faster into 
      the minimum. This will, however, also happen if you happen to be close
      to a local minimum, instead of the global minimum!

   I cannot give a hint regarding the number of generations required.
   This depends too much on the problem at hand, parameter correlation,
   the initial choice of parameters etc.
3  Population_size

   Usually the population size will remain fixed during the course of
   a refinement. The population size is defined by setting appropriate
   values to the variable 'pop_n' and 'pop_c' for the parent and 
   children respectively.

   If you want to change the population size during a refinement, use 
   a sequence of commands as follows:

   read         ! This forces DIFFEV to update the parameters from
                ! GENERATION and the logfiles
   pop_n[1] = <new_value>
   pop_c[1] = <new_value>

   You may increase or decrease the population size as needed.
2  allocate
!p allocate
!p allocate "default"
!p allocate "constraint", <max_constr>
!p allocate "population", <max_members>, <max_parameters>
!p allocate "show"

   DIFFEV allows to to allocate memory for the arrays needed to store the
   population and the constraints. DIFFEV will dynamically allocate
   the population size, the number of refinement parameters and the 
   number of constraints. 
   Thus one often may not have to use this command.

   If previously allocated arrays are reallocated, DIFFEV tries to save
   the old values and you can continue to use these. If the new array
   sizes are smaller than the previous ones, this can obviously not be
   done. DIFFEV will perform the new allocation, but all old data are lost.
   A short warning will be printed.

!p allocate
!p allocate "show"

   Without parameter or with the parameter "show", the allocate command
   shows the current memory allocations.

!p allocate "default"
   Allocates all array sizes to default values.

!p allocate "constraint", <max_constr>

   Allocates the maximum number of constraints that DIFFEV shall handle.

!p allocate "population", <max_members>, <max_parameters>
   Allocate the maximum population size and the maximum number of 
   parameters that can be refined. 
2  adapt
!p adapt "sigma" ,<parameter_number>,[,{"yes"|"no"|<value>}]
!p adapt "lsigma",<parameter_number>,[,{"yes"|"no"|<value>}]

   DIFFEV uses to "sigmas" to handle special situations.

   The global sigma pop_sig[<i>] is used in the following two situations:
   - a new parameter falls outside the range allowed by pop_xmin[<i>] and
     pop_xmax[<i>]. In this case the new parameter is chosen by adding a
     Gaussian random distributed value with sigma pop_sig[<i>] next to the 
     respective boundary.
   - the difference between two parameters is zero. This will usually 
     occur for integer parameters only. In this case the new parameter is
     chosen by adding a Gaussian random distributed value with sigma 
     pop_sig[<i>] to the value of the effective donor.

   If sigma is allowed to adapt during the fit, its value is set to
   (maximum parameter value - minimum parameter value) * <value>
   Thus, as the population converges to a smaller parameter spread, sigma
   dynamically becomes smaller as well. 

   The adaptation can be set for each parameter <parameter_number>
   separately.

   The local sigma is used to modify a member not by differential evolution,
   but by a adding a local shift to the member. The local shift is a 
   Gaussian distributed random value with sigma = <lsigma>.
   Whether DIFFEV uses this mode, is determined  by the ==> variable 
   diff_lo[1]. This gives the probability, that a given member will be 
   modified by the local change instead of differential evolution.
2  backup
!p backup "NONE"
!p backup <input> [,<extension] , <output>

   This command allows you to back up the current best solutions.
   Diffev expects that the current trial solutions are called
   inputfile.????
   or 
   inputfile.????.extension
   where "????" is a four digit integer number with leading zeros.
   Note that the '.' before the number "????" and before the extension
   are mandatory parts of the filename. You need to ensure that your
   version of "kup.diffev.mac" adheres to this standard. 
   If the output file name includes a path, make sure that the output
   directory does exist. DIFFEV does not create the output directory.


   Examples
   backup CALC/calc, FINAL/final
   This form will back up the files 
         "CALC/calc.????" as "FINAL/final.????"
   backup TEMP/calc, tth, FINAL/final
   This form will back up the files 
         "TEMP/calc.????.tth" as "FINAL/final.????.tth"

   If multiple files need to be backed up, use the 'backup' command
   repeatedly:

   backup TEMP/calc, tth,    FINAL/final
   backup TEMP/calc, grcalc, FINAL/final
   These two lines will back up the files 
         "TEMP/calc.????.tth"    as "FINAL/final.????.tth"
         "TEMP/calc.????.grcalc" as "FINAL/final.????.grcalc"

   backup NONE
     Turns off the back up option

   The backup option is useful, if the calculation of the solutions
   takes a long time and involves random configurations. In these cases,
   the extra time required to copy the files may be well invested 
   rather than to calculate these again after the end of the refinement. 
   If the calculation involves random configurations, a repeated 
   calculation of the solutions on which the cost function depends 
   may not yield exactly the same result. With the backup option you
   ensure that you always have those backed up solutions correspond
   to the actual cost function values that DIFFEV used.

   If the calculation of the solutions is quick or if it does not 
   involve random configurations it is faster not to run the backup
   during the refinements. 
2  branch
!p branch kuplot [, "-macro" <macro_name> [ <par1> [ , <par2> ...]]]
!p branch discus [, "-macro" <macro_name> [ <par1> [ , <par2> ...]]]

   Active within the discus suite only!

   Branches to the "kuplot" or "discus" section.

   Within this section any standard KUPLOT command can be
   given. The behaviour of "kuplot" is essentially the same
   as in the stand alone version. Likewise for DISCUS.
  
   The main use will branch to KUPLOT while the discus section
   is run via run_mpi from a DIFFEV slave.

   Optionally the "-macro" qualifier instructs the suite to run the 
   macro <macro_name> (with its optional parameters) before the 
   interactive session is started.
2  compare
!p compare ["silent"]

   This is the main part of the differential evolution section.
   This command reads the current results that the slave program stored
   in files ==> 'restrial' and compares these to the results of the 
   parent generation. A new set of children is calculated according to 
   the differential evolution algorithm. The successful parents are 
   written to the file ==> 'logfile', which stores their respective cost 
   function, and the full parameter set. At the same time the short summary 
   file ==> 'summary' is appended with abbreviated information about the
   last generation.  The new children parameters are
   written to the temporary files ==> 'trialfile'. The current 
   generation is increased in file 'GENERATION'.

   If the optional "silent" qualifier is specified, DIFFEV will not read 
   the result files. Instead, DIFFEV must have received the current results
   by explicitly setting the values of child_val[*] for all children. 
   This option will work only within the discus_suite, which is a
   collection of DIFFEV, DISCUS, and KUPLOT into a common program.
2  constraint
!p constraint <logical expression>

   The parameter range may be restricted by defining one or several constraint
   conditions. Each condition must be a valid logical expression. For 
   details of the syntax see the manual entry under ==> Command language.
   The parameters within the condition are referred to by p[<i>], where
   <i> is parameter number, 1 up to the dimension of the problem at hand.
   The dimension is fixed through parameter ==> 'pop_dimx', see the 
   variable entry.

   Example

!p constraint  p[1].gt.2   # The first parameter must be larger than 2
!p constraint  4.le. p[2]**2 + p[3]**2
!p                         # The sum of parameters 2 and 3 squared must be
!p                         #  equal or greater than 4.

   If a constraint equation is not met, DIFFEV will create a new parameter
   set. This process is repeated until a valid parameter set is found, or
   until DIFFEV has tried so for MAX_CONSTR_TRIAL times. In this latter
   case the program stops.  
2  deallocate
!p deallocate {"all" | "constraint" | "population"}

   This command allows to deallocate memory for the specified program
   segments. This helps to conserve memory, if program sections are no
   longer needed.

   This deallocation applies to memory that you allocated yourself
   and also to memory that DIFFEV has allocated automatically during
   runtime. As DIFFEV does not necessarily know, when you do not need
   the results of certain calculations any longer, it does not
   deallocate the automatically allocated memory sections unless you
   tell DIFFEV to do so.

!p "constraint"
      Free memory associated to the maximum number of constraints.

!p "population"
      Free memory associated to the population size and maximum number
      of refineable parameters.
2  dismiss
!p dismiss {<n> | "all" }

   Set the R-value of the worst <n> parents to a very high value.
   Thus <n> of the next children will definitely have a better R-value
   and replace these parents. 

   This command should be used after you changed the parameter dimension
   and initialised ==> 'init' some or all of the trial values. 
   Otherwise, many or eval all of the new children might not have
   a better R-value than their parents, and as a consequence the 
   (re-)initialization of the trial values may get lost.
2  donor
!p donor {"best" | "random"}

   The donor vector may be chosen in two different ways.
   "best" chooses the parent member that has the best parameter set.
   "random" chooses at random one of the parent vectors as donor vector.
   Two other parent vectors are always chosen at random to form the
   difference vector that is added to the donor vector.
   DIFFEV chooses the effective donor base along the straight line 
   from the current parent vector to the donor. The point along this
   line is determined by the value of "diff_k[1]" (==> variables).
   For diff_k[1] = 0  the effective donor is the parent vector, 
   for diff_k[1] = 1  the effective donor is the donor vector itself.
2  fix
!p fix <parameter_no>, {<value> | "best"}
!p fix <parameter_name>, {<value> | "best"}

   This command fixes the value of parameter <parameter_no> or
   <parameter_name> to 
   <value> for all members of the population. The ==> refine
   flag is turned of for this parameter. 
   If the second parameter is "best", the parameter is set to the
   corresponding value of the current member with the best R-value.

   As a side effect, the values of pop_xmin, pop_xmax, 
   pop_smin, pop_smax are fixed to this new value as well.
2  functions

   The following DISCUS specific functions exist. For a listing
   of general intrinsic functions see help entry 'functions' in
   the 'Command language' section of the online help.

!p par_number(<char_variable>)

   Returns the number of the refinement parameter whose name is
   encoded in the character variable.
   Example:
   line = 'P_length'
   eval par_number(line)

!p par_name(<number>)

   Returns the name of the refinement variable number <number>
2  initialize
!p initialize [ <par_number1> [, <par_number2>]] [, "silent"]
!p initialise "logfile"

   This command initializes the differential evolution sequence. 

   Before using this command, you must have defined:
!p Number of parameters to be defined ==> 'pop_dimx'
!p Size of the parent population      ==> 'pop_n'
!p Size of the children population    ==> 'pop_c'
!p Boundaries for each parameter      ==> 'pop_xmin'
!p                                    ==> 'pop_xmax'
!p Starting intervals for parameters  ==> 'pop_smin'
!p                                    ==> 'pop_smax'
!p Sigmas for parameter adjustment    ==> 'pop_sig'
!p Local sigmas                       ==> 'pop_lsig'
!p Cross over probability             ==> 'diff_cr'
!p Fraction of the difference vector  ==> 'diff_f'
!p Point between parent an donor base ==> 'diff_k'
!p Local search probability           ==> 'diff_lo'


   Without the optional parameters, 'initialize' is used to start
   the generation zero.

   'Initialize' will use this information to generate the zero's generation.
   The file 'GENERATION' is set to generation zero, the population size
   and the number of parameters is written. 
   The files ==> 'logfile' and 'summary' are initialized. Old versions
   with the same name are overwritten!
   The starting parameter values are written to files ==> 'trialfile'
   After the header, each line contains a one parameter, 
   'pop_n' (i.e. the size of the population) lines are written.

   If you want to reinitialize one or several parameters, the
   'initialize' command may be used with the optional parameter(s).
   In this case 'initialize' will simply set the corresponding
   parameter, or parameter range from <par_number1> to <par_number2>
   to the range defined by the values of pop_smin[*] and pop_smax[*].
   A new set of children and the GENERATION file is written.

   If the last parameter is the string "silent", the trial files are
   note written to your disk. DIFFEV expects to be part of a suite 
   program and will transfer the trial parameters directly to the 
   slave program. See also ==> 'trialfile', 'run_mpi', 'compare'
   This option will work only within the discus_suite, which is a
   collection of DIFFEV, DISCUS, and KUPLOT into a common program.

   The second form of the command can be used to initialize just
   the logfiles, see ==> 'logfile', 'summary'.
   This might be helpful if you want to reset the refinement cycle
   to a smaller generation number. For very length refinements with 
   a few thousand refinement cycles and many parameters, a continuation
   will take appreciable time to read all previous cycles. If the
   actual development across the cycles is not relevant to you you 
   can reduces the file sizes drastically be a sequence like:
   pop_gen[1] = 1
   initialise logfile
2  lastfile
!p lastfile <filename>

   This defines the short log file of the parameter evolution. 

   After each generation, the short lastfile <filename> is overwritten
   by the parameters of the current generation.

   It is a SPEC type file that contains all old R-values and parameters.
   Only this last generation makes up a scan. The first column is the 
   member number, the second the R-value and all further columns the 
   respective parameter values.
2  logfile
!p logfile <filename>

   This defines the log file of the parameter evolution. 

   After each generation, the logfile <filename> is appended by the 
   parameters of the current generation.

   It is a SPEC type file that contains all old R-values and parameters.
   Each generation makes up a scan. The first column is the member number, 
   the second the R-value and all further columns the respective parameter 
   values.
2  newparam
!p newparam <name>, <xmin>, <xmax>,<smin>, <smax>  
            [,init:{"keep"|"initialize"}
            [,real:{"real"|"integer"}

   This command defines a new parameter name or changes the setting for 
   an existing parameter name. 
   <xmin>, <xmax> are the absolute lower and upper windows for the
                  parameter. DIFFEV restricts the refinement to this 
                  interval.
   <smin>, <smax> are the lower and upper limit of the starting 
                  window that is used when a parameter is initialized.

   The optional parameter "init" defines if the current parameter
   values for the population are kept at their current values or if 
   this parameter shall be initialized within the start window 
   <smin>, <smax>.

   The optional parameter "type" defines if the current parameter
   shall be treated as a real valued number (the default) or as a
   whole, integer number.

   The command summarizes the individual commands 
     par_name <name>
     pop_xmin[<ipar>] = <xmin>
     pop_xmax[<ipar>] = <xmax>
     pop_smin[<ipar>] = <smin>
     pop_smax[<ipar>] = <smax>
     pop_sig[<ipar>]  = 0.001
     pop_lsig[<ipar>] = 0.0001
     type {"real"<"integer"}.<ipar>
     
2  read
!p read

   This command has been removed.
   Activated again in version 5.29.0

   The read command instructs DIFFEV to read the GENERATION file
   and to determine the population from the Parameter files.

   This command is only needed if you want to add a new parameter 
   to a refinement that you want to continue and the ==> 'newparam'
   command is the first command in DIFFEV after starting the 
   program prior to the ==> 'run_mpi'command.

   Example:
   read
   newpara  P_new, 0.0, 10.0,  10.0, 9.0
   run_mpi discus, dis.diffev.mac, repeat:5, compute:parallel
   compare

   The 'read' command is not necessary if now new parameters
   are defined. In this case, the 'run_mpi' command will
   automatically determine the refinement state from 'GENERATION'
2  refine
!p refine {"all"|"none"|<number> [,<number>...]}
!p refine {"all"|"none"|<par_name> [,<par_name>...]}

   This command allows you to set, which of the variables are refined.
   If you give the parameter number as negative number, the corresponding
   parameter is not refined.

   Currently you can only specify up to 20 variable numbers on 
   one "refine" command line. If you need to specify the behavior
   for more than 20 variables, please use several "refine" commands.
2  release
!p release {<par_name>| <number>} , range:<sigma>
!p   [value:<setpoint>]
!p   [min:<pop_xmin>]
!p   [max:<pop_xmax>]
!p   [dismiss:<number>]
!p   [dismiss:"all"]
!p   [dismiss:"best"]
!p   [dismiss:"none"]

   This command will initialize a parameter named <par_name> 
   to a range around the current best value. Its intent is 
   to act complementary to a ==> 'fix' command. It works 
   in a similar fashion as the ==> 'init' command, but the user
   does not have to ensure that the ranges of 
   pop_xmin to pop_xmax and pop_smin to pop_smax are non-zero.
   
   The parameter will be refined, i.e. the 'release' command
   implies a ==> refine <par_name> command. 

   If the optional parameter 'value:<setpoint>' is present, 
   it defines the setpoint around which the parameter values 
   will be initialized. If the optional parameter is omitted,
   the setpoint defaults to the value of the current best 
   population member.
   The initialization range is set to the setpoint +- range.

   The absolute limits, ==> 'pop_xmin', 'pop_xmax' are set
   to a range of +- 3* <range> around the <setpoint>.
   The original user provided values of
   pop_min or pop_max are replaced by the new values.

   If you need different ranges for pop_xmin and pop_xmax, 
   or if the new limits might be 
   outside a physical limit you need to set the proper
   limits explicitly with the optional parameters
   "min" and "max":
      min:pop_xmin
      max:pop_xmax

   If all the children will produce R-values that are worse
   than the parents, DIFFEV will discard these children and 
   create the next generation based on all parents. As all  
   parents reflect the state prior to the release, they all
   correspond to identical values of the parameter that you 
   wanted to release. In effect, the release is lost. 
   To prevent this, the 'dismiss:' option will set the R-value
   of a user specified number of parents to a very large 
   value. This ensures that the corresponding children will 
   certainly survive into the next generation. 
   The values that the 'dismiss:' parameter may take are:
   <number>  : A number from 0 to the population size pop_n[1]
               The <number> worst parents are dismissed.
   "all"     : All members are dismissed.
   "best"    : All but the best member are dismissed.
   "none"    : No member is dismissed. Same as <number>=0.
2  reset
!p reset

   Resets DIIFEV to the conditions at program start. The generation 
   number is set to zero, the population size, children size and the
   number of parameters is set to the default value of one. All parameter
   names are removed from the list of user variables.

   Use this command if you want to combine several refinements
   for different experimental data to be executed one after the other.
   Without the reset, the old parameters would persist and may
   interfere with your new parameters. 
2  restart
!p restart <user_generation>
   If you set <user_generation> to a value that is less than
   the current value in GENERATION, 
   the Logfiles, Summary and Last files are 
   shortened and the GENERATION file is adapted. 
   This lets you step back to an earlier refinement status.
   Keep in mind that the later cycles are irrevocably lost.
   If in doubt make a backup first.
2  summary
!p summary <filename>

   This defines the log file of the R-value/cost function evolution. 

   The SPEC type summary files contains a single scan. Each generation 
   creates one line within the scan. The first columns is the generation
   number. For the R-value and each of the parameters four columns are
   written. The first of these is the average value, the second the 
   minimum value, the third the maximum value and the fourth the sigma of
   the parameter distribution.
2  restrial
!p restrial "silent" {,partial:<no>}
!p restrial <result> {,partial:<no>}

   Within the discus_suite always use the "silent" mode!

   These temporary files are used to communicate the R-value from the 
   slave program back to DIFFEV. 
   DIFFEV expects a separate file for each member of the population. 
   The filename <result> is automatically augmented by a four digit 
   member number. Thus, if the filename is Results, DIFFEV expects to 
   find the files:
!p Results.0001
!p Results.0002
!p etc.
   The file contains one line with two numbers, the member number and 
   the R-value obtained for the corresponding set of parameters in 
   file ==> 'trialfile'.

   If the file name is the string "silent", the result files are
   note read from your disk. DIFFEV expects to be part of a suite 
   program and will expect that the result values have been
   transferred directly from the slave program. 
   See also ==> 'trialfile', 'run_mpi', 'compare'

   The optional parameter "partial:<no>" tells DIFFEV how many
   partial R-values to expect from the slave program. 
   Within DIFFEV the partial R-values are just archived, the slave
   program has to provide the properly weighted average R-value.

2  run_mpi
!p run_mpi <program_name>, <macro_name>, <no_repetitions>, <output_base> [,"socket"]

   This command starts the processing of the slave program <program_name>.
   If the program has been compiled with MPI and started with mpiexec,
   a parallel computation is started. Otherwise the slave program is
   executed in a serial loop over all children and individual repetitions.

   This command starts parallel processing of program <program_name>.
   The program will be executed <pop_c>*<no_repetitions> times.
   <pop_c> is the number of children for the current refinement and 
   each child corresponds to one ==> trialfile. 
   The calculations can be repeated <no_repetitions> times, with the identical 
   parameter set. This may be necessary, if you need to average several
   calculations.

   MPI option:
   The standard output of the program will be directed into a file
   <output_base>. The current child number ( and the current repeat
   number, if present) will be appended as four digit wide field.
   On a UNIX system you can redirect the output to /dev/null.

   NON MPI option:
   Regardless of the value of <output_base>, the output is displayed
   at the screen. The usual options for the ==> 'set prompt,' command
   do hold.

   Starting with version 5.7 the communication between the diffev section
   and the discus or kuplot section is done via internal variables.
   These are:
   REF_GENERATION  : the current generation number
   REF_MEMBER      : the number of members in the population
   REF_CHILDREN    : the number of children in the population
   REF_DIMENSION   : the number of parameters defined in DIFFEV
   REF_KID         : the current child
   REF_INDIV       : the current repetition for the current child REF_KID
   REF_NINDIV      : the intended total number of repetitions

   The actual parameters are transferred to DISCUS/KUPLOT via variables
   ref_para[...]   : Indices from 1 to REF_DIMENSION

   The capitalization of the refinement variables is intended to 
   distinguish these from user variables. Other than that they should be
   used just as any user defined variable, with no square brackets:
   kid = REF_KID

   IN a similar fashion, the KUPLOT rvalue command transfers its 
   result back to DIFFEV internally. See 'resfile silent'

   Essentially, DIFFEV branches to the section, executes the macro file
   and returns to DIFFEV. As the communication is done via the internal
   variables, the need for the macro parameters included in previous
   version 5.5 and earlier has ceased. You are encouraged not to rely
   on macro parameters but to use the refinement variables.


   If the last optional parameter is "socket", the program will be
   started via a socket connection, else via a single "system" call.

   system == non-socket option:

   Relevant for older verisons (5.6 an earlier only):

   The actual line that starts the program has syntax:
   "program_name" -macro <macro.name> <cwd> <child> <indiv> > <output>

   <macro_name> name of the macro file to be executed
   <cwd>        1st macro parameter string with current directory
   <child>      current child number (1 to pop_c)
   <indiv>      current repetition number (1 to <no_repetitions>)
                This parameter is omitted, if <no_repetitions> is zero
   <output>     File for standard output written by <program_name>

   Example
   run_mpi discus, discus.mac, 5, LOGFILES/d
           Runs discus with macro "discus.mac". For each child the 
           calculation is repeated 5 times. DISCUS output is written
           into files "LOGFILES/d.xxxx.yyyy", where "xxxx" is the 
           child number and "yyyy" the repetition number.
   run_mpi discus, discus.mac, 5, /dev/null
           Same, except that the output is written to "/dev/null" 
           i.e. it is thrown away.
   run_mpi discus, discus.mac, 0, LOGFILES/d
           Same, except that no repetitions are requested. Only one
           calculation is performed per child and the output is
           written to "LOGFILES/d.xxxx". 

   socket option:

   The program is started via socket at the beginning of a refinement. It
   remains active until DIFFEV is terminated. A second, third program may
   be started as well, such as a discus run followed by kuplot.

   The socket option starts the program via the line:
   
   "program_name" -remote -access=127.0.0.0 -port=<port> > <output>

   Thereafter the variables generation, member, children, parameters,
   kid, indiv, nindiv are defined and placed at their proper values.
   The corresponding lines are 
   variable integer,generation
   generation = <value>
   And so on for the other variables.
   For each calculation i.e. combination of kid, indiv the current 
   values are sent for "kid" and "indiv". All corresponding trial 
   values are placed into the array "r[*]", into entries 201 to
   201 + <parameters>. Then the calculation macro is started, which
   does of course not have to read the GENERATION and the trial file.
2  selection
!p selection {"compare" | "best","all"}

   This command governs the selection criterion that determines which 
   children and parents survive into the next generation.

!p "compare"    Each child is compared to its immediate parent. The better
!p              of these two will survive into the next generation. It will
!p              serve as one of the parents from which the next children 
!p              are derived using the Differential Evolution Algorithm.
!p              The number of children ==> 'variables' pop_c, should be 
!p              identical to the number of members i.e. parents
!p              ==> 'variables' pop_n.
!p "best","all" All parents and all children are put into a single list.
!p              Of this list the best <pop_n[1]> members survive into 
!p              the next generation. No restriction applies to keep any
!p              parent or any children. 
!p              You are free to use any number of children. If the number of 
!p              children is increased compared to the number of parents, the
!p              selection becomes "tougher" since a smaller percentage of the
!p              whole population survives into the next generation. This will
!p              speed up convergence, yet run a higher risk of getting stuck
!p              in a local minimum.
2  trialfile
!p trialfile <filename>|"silent"

   These temporary files are used to communicate the current set of parameters
   between DIFFEV and the slave program. 

   DIFFEV writes a separate file for each member of the population. 
   The filename <filename> is automatically augmented by a four digit 
   member number. The if the filename is Trials, DIFFEV expects to 
   find the files:
!p Trials.0001
!p Trials.0002
!p etc.

   The file has format:

!p # generation members children parameters
!p      181        45        90         4
!p # current member
!p     1
!p # parameter list
!p     0.8284027688E-02
!p     0.5815573883E+02
!p     0.2050311089E+01
!p     0.3000000000E+01

   The first states the current generation, the number of members in 
   the population, the number of children in each population, and the 
   number of parameters. 
   The next two lines states the number of the current member. 
   This is followed by a list of all parameter values, each in a separate
   line.

   If the file name is the string "silent", the trial files are
   note written to your disk. DIFFEV expects to be part of a suite 
   program and will transfer the trial parameters directly to the 
   slave program. See also ==> 'trialfile', 'run_mpi', 'compare'
   This option will work only within the discus_suite, which is a
   collection of DIFFEV, DISCUS, and KUPLOT into a common program.
2  type
!p type {"integer" | "real"},<number>

   Defines the number that the parameter <number> assumes. Valid options
   are:
!p "integer" The parameter is restricted to integer numbers.
!p "real"    The parameter may take on any real,floating number.

   See the entry on 'variables' regarding options to limit the allowed range,
   and the entry ==> 'constraint' on possible constraints.
2  variables

   Like all programs of the Diffuse suite, diffev offers integer and
   real variable for standard calculations == Command Language/variables

   Unique diffev variables are:

!p pop_gen[1]    The number of the current generation
!p pop_n[1]      The size of the parent population
!p               The size of the population may be changed during a
!p               refinement. In this case the GENERATION file is updated
!p               automatically. If the population is increased, the R-values
!p               for the new members are set to ten times the maximum 
!p               current R-value. Parameter values are copied from old 
!p               member no. one.
!p pop_c[1]      The size of the children population
!p               The size of the children population may be changed during a
!p               refinement. In this case, a new set of trial files is 
!p               automatically generated and the GENERATION file is updated
!p               as well.
!p pop_dimx[1]   The dimension, i.e. the number of parameters
!p               The dimension may be increased during a refinement. To do 
!p               so you need to increase pop_dimx[1], set all parameter
!p               related values for this new parameter and run the 
!p               ==> 'init <par_number>' command. This will initialize the
!p               parameter to the starting range and update the trial files
!p               and the generation file.
!p
!p pop_xmin[<i>] Minimum allowed value for parameter <i>
!p pop_xmax[<i>] Maximum allowed value for parameter <i>
!p
!p pop_smin[<i>] Minimum starting value for parameter <i>
!p pop_smax[<i>] Maximum starting value for parameter <i>
!p
!p pop_sig[<i>]  Sigma of Gaussian distribution for parameter <i>. If the
!p               difference between two parent parameters is zero, or if a
!p               child parameter is outside the limits defined by pop_xmin
!p               and pop_xmax, the corresponding parameter is modified by
!p               a Gaussian distributed random number. 
!p               Set pop_sig to zero to switch off this option.
!p
!p pop_lsig[<i>] Sigma of local Gaussian distribution for parameter <i>. 
!p               The probability diff_lo[1] determines if a given member
!p               is changed locally only or takes part in the usual 
!p               differential evolution algorithm. If it is changed only
!p               locally, the parent parameters are modified by adding
!p               a Gaussian distributed random number, with mean zero 
!p               and sigma pop_lsig.
!p
!p pop_v[<i>,<j>] Value of parameter <i> for member <j>
!p               This parameter is read only.
!p
!p pop_t[<i>,<j>] Current trial value of parameter <i> for child <j>
!p
!p rvalue[<i>]   R-value for member <j>. This is the R-value for the 
!p               current parent generation.
!p
!p bestm[1]      Parent member that currently has the lowest R-value
!p
!p bestr[1]      Currently lowest R-value.
!p
!p worstm[1]     Parent member that currently has the highest R-value
!p
!p worstr[1]     Currently highest R-value.
!p
!p p[<i>]        Parameter symbol used in the constraint conditions.
!p
!p diff_cr[1]    Cross over probability
!p diff_f[1]     Multiplier for difference vector
!p diff_k[1]     Multiplier for vector between parent vector and donor
!p diff_lo[1]    Probability for local refinement of a population member
!p diff_sel[1]   Selection mode for compare command, READ_ONLY
2  write
!p write {"children" | "generation"}

!p write "children"
   The write command will generate a new set of child values and update
   the corresponding trial files and the GENERATION file. The generation
   number is not changed.

!p write "generation"
   Writes the GENERATION file. No changes are done to the file.
