2  Command_language

   All commands consist of a command verb, optionally followed by one
   or more parameters. All parameters must be separated from one
   another by a comma ",". There is no predefined need for any specific
   sequence of commands.

   ! NEW ! 
   Command lines can be continued by placing an "&" as last character 
   into a line. Example
   evaluate 5+6  &  ! the rest is a comment
   +5
   This will effrectively be identical to 
   evaluate 5+6+5

   Commands are case sensitive, all commands and alphabetic parameters MUST
   be typed in lower case letters.

   Only the first four letters of any command verb are significant, all
   commands may be abbreviated even further. At least a single space is
   needed between the command verb and the first parameter. No comma is
   to precede the first parameter. The command verb itself MAY NOT be
   preceded by any blanks.

   All text in an input line that follows a "#" or "!" is treated as
   comment and ignored.

   The word PROG in this part of the help section is to be replaced
   by the name of the program you are using (e.g. DISCUS).

   Further help topics are:
3  News

   Here you find a list of recent changes, additions, bug corrections
4  2022_June

   fget
   Added an optional parameter "hash:sikp" / "hash:read" to sikp/read
   lines starting with a hashh "#". 
4  2022_March

   Adapted optional parameters to handle format specifiers in 
   situations like:
   optional:"Nice %c", value
4  2020_December

   The socket connections have been removed.
4  2020_October

   Added optional parameters 'status:append', 'status:unknown' and
   log:'screen', 'log:off' to ==> fopen command
4  2020_September

   As of version 6.02, the DISCUS_SUITE is compiled with OpenMP as default.
   To allow user flexibility, a new command ==> 'set parallel,...' was added.
   DISCUS_SUITE will check at startup how many physical and logical cores
   are available on your computer. My experience is that performance with
   openMP improves only up to the number of physical cores. Thus the 
   maximum number of parallel threads is initially limited to this number.
   You have control over the number of threads via the 
   ==> 'set parallel' command.

   Added ==> 'show' to the commands available at the SUITE level
4  2020_June

   New commands 'mount' and 'umount' enable access to removable drives
   at Windows. Not relevant for Linux and MACOSX

   Modified "min" and "max" functions to take more than 2 arguments.
   
4  2020_May

   Added the possibility to continue input lines 

   Added a search for a new version at GIThub

   Added the option to place a string into a substring in a character
   expession
4  2019_June

   Modified the test for valid user defined variable names to 
   include a test on all sections.
4  2019_May

   Added a possibility to stop a macro at a 'wait return'
4  2019_March

   Added two more system variables, LOOP and SLOW that can be 
   used as counters in loops.
4  2018_November

   Added a new transfer mode value() to macro parameters. See the
   help entry '@' for further details.
4  2018_September

   Modified the do and if constructions to be valid as well for 
   "end do" "end if" and "else if" with arbitrary blanks.
4  2018_July

   Modified the ==> 'fput' and 'fget' commands to take an optional 
       format string

   Modified the ==> 'system' command to be a bit more flexible

   Modified the ==> function "fmodt" to take a file name as well.
4  2018_June

   Revised the reaction to a CTRL-C

   Added a ==> 'set wait {"on"|"off"} option

   Added a ==> 'set error, ... , "save" option
4  2018_May

   The variables ==> 'variable' were augmented by 1-D and 2-D arrays.
   New commands ==> 'matmul', 'matadd','invmat', 'mattrans', 
   'detmat' provide the usual arithmetics
4  2018_Feb

   New read-only ==> variables "PROGRAM", "STATE", "MPI", "MPI_FIRST"
   were introduced that can be querried to learn in which program 
   section and at what state you are.

   As a patch to overcome internal precision, the ==> 'seed' command
   can take an alternative form.
4  2018_Jan

   The logical comparisons may now take the operators:
   <, <=, ==, /=, >=, >/ 
   The classical fortran77 operators are still valid

   New logical functions "isvar" and "isexp" can be used within an
   "if" construction. See help entry ==>'function'

   New parameters "reset" and "delete" have been added to the 
   ==> 'variable' command
4  2017_November

   A 'manual' command has been added that reads the manual files
4  2017_Sep

   Throughout the program the internal calculation of random numbers 
   was changed to the FORTRAN 90 intrinsic function. 
4  2017_July
   
   Predefined variables REF_* are now read/write. See ==> variable

   Introduced new intrinsic character functions: index and length
   See help under functions for details.
4  2016_October

   New system variables have been introduced. They can be used like any
   other user defined variable. System variables are in capital letters.
4  2014November

   A new random number "gskew" has been added, which returns a 
   Gaussian distributed random number. The underlying distribution
   can be set to be is left or right skewed.
3  Options
!p program [-noautorun] [-debug] [macro.mac]
!p program [-noautorun] -macro <macro.mac>[ <par1> [ <par2> ...]]
!% program [-noautorun] [-debug] [-remote] [-port=p] [-access=ip] [macro.mac]

   If run on operating system Linux or MacOS, the DISCUS_SUITE 
   allows the following command line parameters.

   As of version 6.03 and later, DISCUS_SUITE will look for a macro file
   "autorun.mac". If found, this is run first. Afterwards all other 
   options are set and user supplied macros will be executed. 
   If you do not want the macro "autorun.mac" to be run, start the suite
   with the command line option "-noautorun". This option is compatible
   with the "-macro" option.
   As the Windos icon does not allow you to use optional parameters, 
   the execution of "autorun.mac" is always turned on. At the moment that 
   DISCUS_SUITE looks for the "autorun.mac" file, we are at the folder
   "C:\Users\yourr_account_name", i.e. one level above "Documents".
   To use "autorun.mac" you need to place the macro into this folder. 
   To turn off its use, remove or rename the file.

   The flag "-debug" starts the program in debug mode. 
   This is the same as using the command "set debug,on". 
!% The switch "-remote" starts the program
!% in remote control mode. In this case the commands are send to the
!% program through a socket. In this case the switch "-port' allows one
!% to specify the port, the program will be listening on. Port numbers
!% should be larger than 1024. The switch "-access' allows one to specify
!% from which host connections will be accepted. The default is 
!% 'localhost'.
!%
!% See file "remote.f" for an example how to remote control the 
!% applications from another program. Note that the program will not 
!% accept input from the keyboard when in remote control mode. 

   All other command line arguments are interpreted as macro files
   and will be executed at startup. These macros may not rely on
   parameters to be given on the command line.

   If a macro is to be executed that takes 1 or more parameters, use
   the "-macro" option. Note that this option is mutually exclusive
   to all other options. The first command line argument after  the 
   '-macro' option it the macro name, all further optional command 
   line arguments are taken as macro parameters. These have to be 
   seperated by one or more spaces or comma. 
   Parameters that need to contain spaces must be enclosed in single 
   or double quotation marks.
   -macro test.mac 1 2 3
   This is the same as @test.mac 1,2,3
   -macro test.mac 1, 2 , 3
   This is the same as @test.mac 1,2,3

   -macro test1.mac '1 + 2 + 3'
   This is the same as @test1.mac 1 + 2 + 3
3  #
!p #<comment>

   Any line beginning with a "#" is regarded as comment.
3  @
!p @<filename> [<argument> ...]

   Any list of valid commands can be written to an ASCII file and
   and indirectly by the command:

!p prompt > @<name>

   The commands that are listed within the macro file 
   may start with leading blanks to help readability of 
   the macro file. The commands are executed as typed.
   Macro files may call other macro files. This is not a call in
   the sense of calling a function.
   All variables are identical at all levels of macro file nesting.

   Macro files can be written by any editor on your
   system or be generated by the ==> 'learn' command. 'learn' starts to
   remember all the commands that follow and saves them into the file
   given on the 'learn' command. The learn sequence is terminated by
   the 'lend' command. The default extension is ".mac"

   Optionally arguments can be listed on the command line. These arguments
   will replace the formal parameters inside the macro. The formal
   parameters must be given as "$1", "$2" ... The string <argument> will
   replace the string "$1". "$1" is the first argument on the command line,
   "$2" the second and so on. If there are not enough command line arguments,
   an error message is displayed.
   The parameter "$0" contains the number of parameters listed on the line
   that called the macro. If no parameters were given this value will be 
   zero.

   Starting with version 5.29.0 the parameters on the macro command line
   may also be written as "value(<expression>)". In this case the 
   corresponding formal parameter in the macro is replaces by the 
   string that corresponds to the value of the expression.  

   The prompt setting ==> 'set prompt,"redirect"' has an important side 
   effect on macro treatment. 
   With the "redirect" setting, macros are stored internally,
   once they have been read from disk, and will be reused from memory. This
   helps to reduce unnecessary I/O, especially when you have nested macros
   inside loops. As a side effect, if a macro is modified on the disk, 
   a further "@macro.mac" will not read the modified version but will
   continue to use the internaly stored version.

   For all other settings, the internal macro storage is 
   cleared when you get back to the normal interactive mode. This allows
   you to run a macro, then modify the version stored on the disk and 
   execute the modified/corrected version.

   Example 
   assume that a macro file example.mac contains the lines:
   echo $1
   echo $2

   If this macro is started with :
   @example.mac 123.+456., abcd
   the lines that DISCUS_SUITE will actually execute are:
   echo 123.+456.
   echo abcd

   If this macro is started with :
   @example.mac value(123+456), abcd
   the lines that DISCUS_SUITE will actually execute are:
   echo  579.0000000
   echo abcd

   In this second example "$1" has been replaced by the value 
   of the expression "123.+456.", while "$2", has been replaced 
   by the string "abcd". 

   The expression within the "value()" function may be any
   arithemtic or character expression as for example:
   value(sin(PI/2))
   value("base_%4D", i[0])

   This last line is very helpful, if you want to replace a 
   string at a position, where DISCUS_SUITE does not perform
   a string manipulation operation. If the macro contains a 
   line like "variable integer, $1" a call to this macro
   in the form '@macro.mac value("base_%4D", 1234)'
   would actually execute the command
   variable integer, base_1234
   Most DISCUS_SUITE commands that expect a file name will
   allow you to replace a constant file name with a 
   character expression. There are, certainly many parts
   of the program where this character substitution is not 
   implemented. Masking it through a macro parameter
   value(expression) gives you full control.
3  =
!p <variable> = <expression>

   The expression on the right of the equal sign is evaluated and its result
   stored in variable <variable>.
3  input
!p Input editing functions

   If the program was compiled with -DREADLINE, the following basic
   editing functions are available at the program prompt:

!p   ^A               : moves to the beginning of the line
!p   ^B               : moves back a single character
!p   ^E               : moves to the end of the line
!p   ^F               : moves forward a single character
!p   ^K               : kills from current position to the end of line
!p   ^P or arrow up   : moves back through history
!p   ^N or arrow down : moves forward through history
!p   ^H and DEL       : delete the previous character
!p   ^D               : deletes the current character
!p   ^L/^R            : redraw line in case it gets trashed
!p   ^U               : kills the entire line
!p   ^W               : kills last word

   Furthermore you can move within the line using the arrow keys.

!p NOTE:

   If you redirect the input for executed PROG using 'prog < infile' you
   MUST use the command 'set prompt,off' or 'set prompt,redirect' in
   the first line to avoid that the program 'hangs' at the end of the
   file. (-> set prompt)
3  break
!p break <levels>

   The 'break' command stops the execution of the current block structure
   and advances to the next command following the block structure.
   With <levels> equal to 1 only the current block structure is interrupted,
   with any higher number the <levels> innermost block structures are
   interrupted. The 'break' command can be used only inside a block structure.
3  cd
!p cd [<directory>]

   This command allows one to change the current working directory
   (may not be available everywhere). If the command is called with
   no parameters, the current working directory is shown.

   For the Windows versions, two different styles help to copy the 
   folder name into the program window. 

   Type 
   cd 
   and a space. Do not hit the enter/return key at this moment. 
   Within a Windos Explorer click on the folder icon and copy the 
   string CTRL-c. Activate the KUPLOT or DISCUS_SUITE program and 
   click the middle mouse button. This should paste the full path
   to the folder into the KUPLOT or DISCUS_SUITE window. 
   Alternatively past with SHIFT+CTRL-c.

   Special directory names
   $HOME     => /home/<your_user_name>     ! at Linux / MAC / WSL
   $HOMEPATH => c:\Users\<your_user_name>  ! at WSL
             => /home/<your_user_name>     ! at Linux
   $WSL_DOC  => /home/<your_user_name>/Documents ! at WSL
   $WSL      => /home/<your_user_name>           ! at WSL
   To prevent macro errors, the last two special names work for
   Linux and MAC as well. If not $HOME/Documents directory exists
   you will get an error message.

   For Windows only:
   If the drive refers to a removable disk, you might be prompted
   for the Linux password. As Discus does not know if you do not
   need the drive any longer, you have to dismount it explicitely
   with a ==> 'umount' command. Otherwise Windows will not let you
   remove the drive. 

3  continue
!p continue [ "prog" ]

   This command is effective only while PROG is in the interrupted
   macro mode or inside interrupted do-loop or if-statements, which serves
   as a debug mode for lengthy macros or block structures
   Make sure you have returned to the same sub menu before you continue!

   Without parameters PROG resumes the execution of a macro or block
   structure in the line following the 'stop' command. If you
   had started another macro while debugging a macro, and this new macro
   contained a 'stop' command as well, the 'continue' command will run
   the remaining lines in the new macro and then stop again at the position
   of the 'stop' command in the outer macro.

   By providing the 'prog' parameter, PROG immediately interrupts all
   macros and returns to the normal prompt.
   If you are in one of the sub sections "discus", "diffev", "kuplot", 
   you can continue either with this subsection or go back to the main 
   suite if you enter the program name as "suite".
3  do
   Loops can be programmed with the 'do' command. The command may take
   the  following forms:
!p do <variable> = <start>,<end> [,<increment>]
!p   <commands to be repeated>
!p enddo

   Here loops may contain constants or arithmetic expressions
   for <start>, <end>, and <increment>. The internal type of the
   variables is real. The loop counter is evaluated from
   (<end> - <start>) / <increment> =1 . If this is negative, the loop
   is not executed at all.

!p do while (<logical expression>)
!p   <commands to be repeated>
!p enddo

   These loops are executed while <logical expression> is true.
   Thus, they may not be executed at all.
!p do
!p   <commands to be repeated>
!p enddo until (<logical expression>)

   These loops, however, are always executed once, and repeated
   until <logical expression> is true.
   If an error occurs during execution of the loop, the loop is
   interrupted.

   As of version 5.25.1 and later, the word "enddo"
   may also be spelled "end do", where the number of blanks
   that follow the "end" is not significant.
3  echo
!p echo [<string>]
!p echo ["string%dstring",<integer expression>]
!p echo ["string%Dstring",<integer expression>]
!p echo ["string%fstring",<float expression>]
!p echo ["string%Fstring",<float expression>]
!p echo ["string%cstring",<character expression>]

   The string <string> is echoed to the default output device as typed.
   This command serves as a marker inside long macro files. It gives the
   user a chance to include easy to find messages in order to follow
   lengthy or nested structures.

   The alternative command format allows to echo formatted strings to the
   screen. Each "%d" is replaced by the value of the corresponding
   parameter. The sequence of "%d" corresponds to the sequence of the
   integer parameters, "%f" stands for parameters of the type real.

   The value of a numerical expression between the "%" and the "d"
   determines the width of the integer field that is printed. 
   In the case of a floating variable two expressions separated by
   a decimal point specify the width and the number of decimal
   digits that are printed.

   The capital forms "%D" and "%F" will fill leading spaces with zeros.

   A character format descriptor "%c" or "%Nc", with N an integer 
   number, describes a string of characters.

!p Examples
!p echo ">%3d<",44            produces :  > 44<
!p echo ">%1+2d<",44          produces :  > 44<
!p echo ">%3D<",44            produces :  >044<
!p echo ">%5.1f<",44.1        produces :  > 44.1<
!p echo ">%2**2+1.1f<",44.1   produces :  > 44.1<
!p echo ">%c<",'bla'          produces :  >bla<
!p echo ">%5c<",'bla'         produces :  >bla  <
3  evaluate
!p evaluate <expr> [, <expr> ...]

   Evaluates the expression(s) and displays the result(s). The result is not
   stored, this command is for interactive display only.
3  exit
!p exit

   Terminates the program and gets you back to your shell.
3  expressions

   Arithmetic expressions can be evaluated in a FORTRAN style.
   Character expressions are used to assign a string of characters to 
   a variable or filename.

4  Arithmetic expressions:

   Five basic operators are defined:

!p "+"  Addition
!p "-"  Subtraction
!p "*"  Multiplication
!p "/"  Division
!p "**" Exponentiation

   The usual hierarchy of operators holds.
   The parts of the expression can be grouped with parentheses "(",")" in
   order to circumvent the standard hierarchy
   Several intrinsic functions have been defined, see "functions" for a
   full listing.

   Examples of valid expressions are:

!p 1
!p 1+3*(sin(3.14*r[1]))
!p x[1]*0.155
!p asind(0.5)

4  Character expressions

   A character expression is signaled by a pair of " ". The content may
   be a just a simple string of characters or additional format 
   specifiers that are replaced by the value of a variable.

!p variable character,string
!p variable character,line
!p string = "abcdefgh"
!p line   = "%4c",string(2:5)
!p line   = "%c %c",string(1:2),string(7:8)
!p line   = "Number: %3d",4
!p line   = "Number: %3.1f",4.1
!p line   = string          ! Both commands work, 
!p line   = "%c",string     ! this is the prefered style
!p line   = "%c",fdate(0)   ! See ==> functions for a list of 
!p                          ! character functions
!p line(3:7) = 'Hello'      ! Place the sting into character 3 to 7
!p line(:7)  = 'Hello'      ! Place the sting into the first seven 
!p                          ! characters
!p line(8:)  = 'Hello'      ! Place the sting into the characters  
!p                          ! 8 and above

   Within an ==> 'if' construction you may also specify a character
   expression in the form:

!p if( '"%2c",string(3:4)' .eq. 'cd' ) then

   An expression (M:N) refers to the substring from the M's to the N's
   character.

4  Format specifiers

   In filenames ==>"filename" or character expressions format specifiers
   are used to write the value of numerical or character variables into
   the corresponding string. These format specifiers may be:

!p %d      writes a decimal/integer number, the number of digits 
!p         depends on the numerical value of the number
!p %D      writes a decimal/integer number, the number of digits 
!p         depends on the numerical value of the number
!p %3d     writes a decimal/integer number that fills 3 digits
!p %3D     writes a decimal/integer number that fills 3 digits,
!p         leading blanks are filled with zeros
!p         Any width larger than the number of digits required is allowed

!p %Md     writes a string M digits wide. M may be omitted.
!p         M may be an integer expression.
!p         d or D are allowed, D give leading zeros

!p %f      A floating/real number is written flushed left into a 
!p         character string of 8 digits
!p %F      A floating/real number is written flushed left into a 
!p         character string of 8 digits
!p %12.3f  A floating/real number is written flushed right into a
!p         character string of 12 digits. 3 digits are used for the
!p         fractional part. 
!p %12.3F  A floating/real number is written flushed right into a
!p         character string of 12 digits. 3 digits are used for the
!p         fractional part. Leading blanks are filled by zeros.

!p %M.Nf   writes a string M digits wide. N may be omitted.
!p         M and N may be integer expressions.
!p         f or F are allowed, F give leading zeros

!p %c      A character string is written, the width depends on the input
!p         variable
!p %5c     A character string of 5 characters is written.

   Examples

!p variable character,string
!p variable character,line
!p string = "abcdefgh"
!p line   = "%c",string     ==> "abcdefgh"
!p line   = "%4c",string(1:4)     ==> "abcd"
!p line   = "Hallo %c",string(2:4)    ==> "Hallo bcd"
!p line   = "Number %5d",1234         ==> "Number  1234"
!p line   = "Number %5D",1234         ==> "Number 01234"
!p line   = "Float  %8.3f",3.1415     ==> "Float     3.141"
!p line   = "Float  %8.3F",3.1415     ==> "Float  0003.141"
3  filenames
   Usually, file names are understood as typed, including capital
   letters. Unix operating systems distinguish between upper and lower
   case typing !

   Additionally (integer) numerical input can be written into the
   filename. The syntax for this is:

!p "string%dstring",<integer expression>
!p "string%fstring",<real expression>
!p "string%cstring",<character expression>

   The file format MUST be enclosed in quotation marks. The position of
   each integer must be characterized by a "%d". The sequence of strings
   and "%d"'s can be mixed at will. The corresponding integer expressions
   must follow after the closing quotation mark. If the command line
   requires further parameters (like "addfile" for example) they must
   be given after the format-parameters.
   The interpretation of the "%d"'s follows the C syntax. Up to 10 numbers
   can be written into a filename.

   Refer to the help entry "expressions" for further help.

   Examples:
!p 1)
!p i[5]=1
!p outfile a1.1
!p outfile "a%d.%d",1,1
!p outfile "a%d.%d",4-3,i[5]
!p outfile "a%1.1f",1.1

   All the above examples will result in the file name "a1.1".

!p 2)
!p do i[1]=1,11
!p ...
!p outfile "data%d.calc",i[1]
!p ...
!p enddo

   The output is written to the files "data1.calc" through "data11.calc"
3  fclose
!p fclose {<number>|"all"}
 
   This command closes a file that was opened with 'fopen <number>' or
   closes all open files. If this
   command is not used before exiting the program, data might be lost !
3  fend
!p fend <number>,{'continue'|'error'}

   This command determines the reaction to an unexpected end of file
   while reading data from input file <number>.
   If the parameter is set to "continue", the program will set the variable
   res[0] to -1 and continue the macro. If you repeat the  ==> 'fget'
   command, the program will again set res[0] to -1 and will not result 
   in an error. In order to catch and EOF, you have to evaluate the 
   value of res[0] each time the 'fget' command is executed.

   If the parameter is set to "error", the program will stop reading
   data from the input file and terminate the macro with an error 
   message. The value of res[0] remains undefined.

   The default condition at program start is "error"
3  fexist
!p fexist <file>

   This command checks the existence of the specified file <file>. The
   result is written on the screen and returned via the res[] variables.
   If the file exists, res[1] is 1, otherwise it is 0. The variable
   res[0] returns the number of parameters, here 1.
3  fformat
!p fformat <nc>,<format>

   This command allows one to specify a FORTRAN style format string
   <format> to be used for column <nc>. The default is free format,
   which can be selected using the character * as format string. If 
   the command is called with no parameters, the current settings are
   displayed on the screen. Note that an unsuitable format might 
   result in a conversion error and *** being written to the file !

!p Example: fform 1,F7.3
3  fget
!p fget <number>,<p1>,<p2>,..
!p               [, "form:'<string>'"] 
!p               [, "hash:skip | hash:read"]]

   This command allows the user to read data from a file that had been 
   opened with 'fopen <number>. If no parameters are given, a line is
   read, yet its content is ignored and the line gets skipped.
   Otherwise the read numbers will overwrite the contents of the 
   specified variables.
   The values in the input file must be separated by a blank or a comma.
   This means that to read a set of words in "This is a sentence", you
   will have to read this into 4 character variables.

   Note that a 'fget' command that does not run into an unexpected 
   end of file sets the value of res[0] to zero!

   The optional format string allows to specify an input format.
   The format string has to specify the format for each input parameter.
   It thus takes a comma delimited list of Fortran style descriptors:
   i<length>         Integer = Whole number 
                     As in "i4"  or "i17" 
   f<length>.<dec>   Floating point number:
                     As in "f8.3". Only the overall length <length>
                                   is relevant, the length of the 
                                   digits after a decimal point is ignored.
                                   Thus, other than in Fortran you 
                                   can write:
   f<length>         As in "f8" or "f12"
   a<length>         Character = alphanumeric string
                     As in "a20"

   The optional parameter "hash" determins how lines that start with a
   hash "#" are treated. By default or "hash:skip" these lines are 
   skipped and fget automatically reas the next line. With "hash:read" 
   the lines are read into the input variable. 

   Example: 
   Assume a file "example.text" with the following content:

   3.1415  123456
   2.7182817 Hello 654321
   This is a sentence

   This can be read with the following instructions

   fopen 1, example.text
   variable character, str_a
   variable character, str_b ! formats are optional for line 1, and 2
   fget 1, r[2],i[2]         , form:'f6,i8'
   fget 1, r[2],str_a,i[2]   , form:'f9.7,a5,i7'
   fget 1, str_b             , form:'a18'        ! whole string is read
   fclose 1
3  fopen
!p fopen <number>,<file> [,{"append" | "overwrite"}]
!p       [,status:["append"|"unknown"]], [,log:["screen"|"off"]]

   This command allows the user to open a file for reading and writing
   using the commands 'fget' and 'fput'. The first argument is the number
   of the io_stream. You can open several files at once, the exact value
   depends on the value of the variable MAC_MAX_IO in file "macro.inc".
   The second argument is the file name. The default is that existing 
   files will be overwritten if 'fput' is used. Alternatively one can 
   append data to a file by specifying the optional parameter "append".

   The optional parameter 'status' equivalently allows to differ between 
   "append" and overwrite mode.
   The optional parameter "log" allows to write to "screen" or to 
   suppress a message that the file was opened. 
3  fput
!p fput <number>,<p1>,<p2>, ..
!p               [, form:'<string>'] 

   This command allows one to write data to the file that had been opened
   by 'fopen <number>'. The parameters <pi> can either be variables and
   expressions or simple text enclosed in single quotes. If no parameters
   are given, an empty line is written.
   In order to mix character variables or character functions and numbers,
   the first parameter must be a format descriptor in double "".

   The optional format string allows to specify an output format.
   The format string has to specify the format for each input parameter.
   It thus takes a comma delimited list of Fortran style descriptors:
   i<length>         Integer = Whole number 
                     As in "i4"  or "i17" 
   f<length>.<dec>   Floating point number:
                     As in "f8.3". Total width is 8 digits with 3
                                   digits after a decimal point.
   a<length>         Character = alphanumeric string
                     As in "a20"

   The optional format string effectively replaces the
   ==> 'fformat' command. 

!p Examples:  fput 1, i[1],sqrt(1.0+i[1]*0.01)
!p            fput 1, 'Current value of i[1] : ',i[1]
!p            fput 1, "%c %d",'Current value of i[1] : ',i[1]
!p            fput 1, "%c",fdate(0)
!p            fput 1, 1,2,3, form:'i3,i3,i3'
!p            fput 1, 1,3.1415,3, form:'i3,f8.4,i3'
3  fsub
!p fsub <number>,[<left>,<right>]

   The command allows you to limit the string from which 'fget' reads the
   data from file <number>. Data will only be read columns <left> to <right>.
   If both parameters are missing, the full input string is read. 
   If the parameter <right> is set to "-1", the string is read from <left>
   all the way to the end of the input string, independent of its length.

   The default values at program start are 1,-1 for all input channels.

!p Examples:  
!p   Input line: "A text string 20.0  30.0"
!p   fsub 14,24
!p   fget r[1],r[2]
3  functions

   The following intrinsic numerical functions exist:

!p asin(<arg>)                     !
!p acos(<arg>)                     !
!p atan(<arg>)                     !
!p atan(<arg1>,<arg2>)             ! Arguments are sine and cosine of angle
!p asind(<arg>)                    ! Result in degrees
!p acosd(<arg>)                    ! Result in degrees
!p atand(<arg>)                    ! Result in degrees
!p atand(<arg1>,<arg2>)            ! Arguments are sine and cosine of angle

!p sin(<arg>)                      !
!p cos(<arg>)                      !
!p tan(<arg>)                      !
!p sind(<arg>)                     ! Argument in degrees
!p cosd(<arg>)                     ! Argument in degrees
!p tand(<arg>)                     ! Argument in degrees

!p sinh(<arg>)                     ! Hyperbolic functions
!p cosh(<arg>)                     !
!p tanh(<arg>)                     !

!p sqrt(<arg>)                     ! Square root of <arg>
!p exp(<arg>)                      ! exponential (base e)
!p ln(<arg>)                       ! natural logarithm of <arg>
!p abs(<arg>)                      ! Absolute value of <arg>

!p mod(<arg1>,<arg2>)              ! Modulo <arg1> of <arg2>, real arguments
!p max(<arg1>,<arg2> [, <argi>])   ! Maximum of all arguments, at most 30 args.
!p min(<arg1>,<arg2> [, <argi>])   ! Minimum of all arguments, at most 30 args.

!p int(<arg>)                      ! Convert argument to integer
!p nint(<arg>)                     ! Convert argument to nearest integer
!p frac(<arg>)                     ! Returns fractional part of <arg>

!p ran(<arg>)                      ! Returns uniformly distributed pseudo
!p                                   random value 0<= r < 1.

!p gran(<arg>{,"s"|"f"})           ! Returns gaussian distributed pseudo
!p                                   random value with mean 0.0 and 
!p                                   sigma <arg> or FWHM <arg> if the 
!p                                   second argument is equal to "f". 

!p gskew(<arg>,<skew>{,"s"|"f"})   ! Returns gaussian distributed pseudo
!p                                   random value with mean 0.0 and 
!p                                   sigma <arg> or FWHM <arg> if the 
!p                                   second argument is equal to "f". 
!p                                   If skew is 0 the distribution is symmetric
!p                                   For skew <=  1.0 it is right skewed
!p                                   For skew >= -1.0 it is left  skewed

!p logn(<arg1>,<arg2>{,"s"|"f"})   ! Returns lognormal distributed pseudo
!p                                   random value. <arg1> is the location 
!p                                   of the most likely value. 
!p                                   <arg2> is the width of the distribution.
!p                                   More accurately, <arg2> is the width of 
!p                                   the underlying distribution ln(logn).
!p                                   It is either sigma <arg2> or FWHM <arg2> 
!p                                   if the third argument is equal to "f". 

!p lognormal(x, my, p_sigma)       ! Returns the probability density function
!p                                   for a normalizes lognormal distribution
!p                                   with parameters my and p_sigma at the 
!p                                   position x.

!p pois(<arg>)                     ! Returns Poisson  distributed pseudo
!p                                   random value with mean <arg>.

!p psvgt(<x>,<eta>,<integral>, <pos>, <FWHM> [, <asym_1>, <asym_2>]
!p       ,wave:<symbol>, itwo:<Int2/int1>  )
!p                                   Returns a Pseudo-Voigt function
!p                                   eta * lorentzian + (1-eta) * gaussian
!p                                   with integral intensity <integral>
!p                                   at position <pos> and FWHM
!p                                   Two optional asymmetry parameters allow 
!p                                   to calculate an asymmetric profile shape.
!p                                   at asym=0 a symmetric profile results.
!p                                   The combination of "wave" and "itwo"
!p                                   will generate a doublet like Copper
!p                                   Kalpha1,2. Allowed wave length are
!p                                   same as for DISCUS powder / Fourier 
!p                                   calculations.

!p pears(<x>,<m>,<integral>, <pos>, <FWHM> [, <asym_1>, <asym_2>]
!p       ,wave:<symbol>, itwo:<Int2/int1>  )
!p                                   Returns a Pearson Type VII function
!p                                   with shape parameter <m>
!p                                   with integral intensity <integral>
!p                                   at position <pos> and FWHM
!p                                   Two optional asymmetry parameters allow 
!p                                   to calculate an asymmetric profile shape.
!p                                   at asym=0 a symmetric profile results.
!p                                   The combination of "wave" and "itwo"
!p                                   will generate a doublet like Copper
!p                                   Kalpha1,2. Allowed wave length are
!p                                   same as for DISCUS powder / Fourier 
!p                                   calculations.

!p tukey(x, <alpha> [, <width>])
!p                                   Returns a Tukey window function
!p                                   1/2[1-cos/2PIx/(alpha*width))
!p                                   for 0<=x< 1/ alpha*width
!p                                   Symmetric at width/2
!p                                   zero outside the range 0:width
!p                                   The width defaults to 1.0

   The arguments to any of these functions are any arithmetic expression.

   System functions:

!p date(0)                         ! Returns the current date as character
!p                                   string in the format:
!p                                   CCYYMMDDhhmmss.sss
!p                                   CCYY  : year    (century, year)
!p                                   MM    : month   (1,2,... 12)
!p                                   DD    : day     (1,2,... 31)
!p                                   hh    : hour    (1,2,... 24)
!p                                   mm    : minute  (1,2,... 60)
!p                                   ss.sss: second.milliseconds
!p                                   (g77: milliseconds are 000)
!p fdate(0)                        ! Returns the current date as character
!p                                   string in the format:
!p                                   Day Mon DD hh:mm:ss CCYY
!p                                   Day   : weekday (Mon, Tue,... Sun)
!p                                   Mon   : month   (Jan, Mar,... Dec)
!p                                   DD    : day     (1,2,... 31)
!p                                   hh    : hour    (1,2,... 24)
!p                                   mm    : minute  (1,2,... 60)
!p                                   ss    : second  (1,2,... 60)
!p                                   CCYY  : year    (century, year)
!p fmodt(0)                        ! Returns modification date and time
!p                                 ! of the last file that was opened by 
!p                                 ! the Discus_suite.
!p fmodt('name')                   ! Date for file "name"
!p fmodt(<line>)                   ! Date for file in variable <line>
!p                                 ! The format ! is the same as for fdate(0)
!p getcwd(0)                       ! Returns the current directory as
!p                                   character string.
!p getenv('name')                  ! Returns the value of the environment
!p                                   variable "name".
!p getenv(<line>)                  ! Returns the value of the environment
!p                                   variable that is stored in variable <line>.
!p index(<line>, <substring> [,"BACK"]) ! Returns the location of the
!p                                   substring within the line.
!p                                   If the optional keyword "BACK" is present,
!p                                   index returns the last occurence.
!p                                   Both, the line and the substrings may be
!p                                   given as simple strings in single quotations
!p                                   or as a variable with with a preceeding
!p                                   format specifier, Examples:
!p                                   line ='Discus'
!p                                   index('Discus','s')
!p                                   index('Discus','s', BACK)
!p                                   index("%",'Discus',"%",'s')
!p                                   index("%",line    ,"%",'s')
!p                                   index("%c",getcwd(0), '/')
!p length(<line>)                    !Returns the length of string <line>
!p                                   The line may be
!p                                   given as simple strings in single quotations
!p                                   or as a variable with with a preceeding
!p                                   format specifier, Examples:
!p                                   length('Discus')
!p                                   length("%c",line)
!p                                   index("%c",getcwd(0), '/')
!p isvar('string')                   Returns TRUE if the string is a used
!p                                   defined variable. Can only be used inside
!p                                   an if construction:
!p                                   Examples:
!p                                   if(isvar('name')) then
!p                                   if(isvar('$1')) then
!p isexp('string')                   Returns TRUE if the string is a valid
!p                                   expression. Can only be used inside
!p                                   an if construction:
!p                                   Examples:
!p                                   if(isexp('3+5.')) then
!p                                   if(isexp('$1')) then
3  help
!p help [<command> [, <subcommand>] ]

   The 'help' command is used to display on-line help messages. They are
   short notes on the command <command>. The command may be abbreviated.
   If the abbreviation is not unique, only the first help topic that matches
   the command is listed.

   The first line of the help text gives the syntax of the command that is
   explained in the following lines. For a few commands the syntax line is
   repeated for different set of possible parameters.

   After the text is displayed, you are in the HELP sublevel of PROG
   and there are the following commands possible:

!p <command> : Display help for <command> of current help level.
!p ".."      : Go up one help level.
!p "?"       : Prints list of help entries of the current level.
!p <RETURN>  : Exit help sublevel.


   Within this help, text that is written as:
   <text>    : in pointed brackets : This text is to be understood as text
                                     or command or number that you have to
                                     type when using the actual command.
                                     Omit the pointed brackets.
   "text"    : in quotation marks  : This text is to be understood as the
                                     explicit test that is given.
                                     Omit the quotation marks.
   'command' : in single quotes    : Refers to commands of suite, discus etc.
3  if
   The if-control structure takes the following form:

!p if ( <logical expression> ) then
!p   <conditional commands>
!p [elseif ( <logical expression>) then
!p   <conditional commands>]
!p [else
!p   <conditional commands>]
!p endif

   The logical expressions may contain numerical comparisons with syntax:

   As of version 5.25.1 and later, the words "elseif" and "endif"
   may also be spelled "else if" or "end if", where the number of blanks
   that follow the "end" is not significant.

!p <arithmetic expression> <operator> <arithmetic comparison>

   The following operators are allowed:

!p  <      ! less than
!p  <=     ! less or equal
!p  >      ! greater than
!p  >=     ! greater or equal
!p  ==     ! equal
!p  /=     ! not equal

   The older forms are still valid:
!p .lt.    ! less than
!p .le.    ! less or equal
!p .gt.    ! greater than
!p .ge.    ! greater or equal
!p .eq.    ! equal
!p .ne.    ! not equal

   The logical expressions may also contain string comparisons with syntax:

!p '<string1>' <operator> '<string2>'

   Both strings MUST be enclosed by single apostrophes '. The operators
   are the same as those for the numeric expressions, lexical comparisons
   are used to evaluate the comparisons "less" and "greater".
   Within the single apostrophes you can place a character replacement 
   operation. Thus a valid example would be:
   variable character, line
   line='text'
   if( '"%c",line' .eq. 'text' ) then

   Logical expressions can be combined by logical operators:

!p .not.   ! negation of the following expression
!p .and.   ! logical and
!p .eqv.   ! logical equivalent
!p .xor.   ! logical exclusive or
!p .or.    ! logical or

   Logical operations may be nested and grouped by brackets "(" and ")".
3  learn
!p learn [<name>]

   Starts a learn sequence. All following commands are saved as typed
   in file <name>. defaults to "<prog>.mac". ==> lend finishes the
   learn sequence.
3  lend
!p lend

   Finishes the learn sequence started by ==> learn.
3  manual
!p manual ["section:"{"suite"  | "discus"  | "diffev" |
!p                    "kuplot" | "package" | "refine"}]
!p        [,"viewer:"<name>]

   Opens a PDF viewer for one of the Manuals

   The section defaults to the current program section that you are
   working with.
   On Linux systems, the viewer defaults to "qpdfview", on Windows 
   system it defaults to "firefox". If DISCUS does not find the
   default or the user provided viewer, DISCUS will search
   a list of common PDF viewers. If none is found an error message
   points to the folder that contains the manuals.
3  mount
!p mount <drive>
!p mount <drive:>

   This command is relevant for the Windows version only. 
   It anables access to removable drives like "F:" etc. 
   Unfortunately at the moment The Linus Subsystem does not 
   perform an automount. 
   A mount is performed automatically if you use the ==> 'cd' command.

   See also ==> 'umount'
3  seed
!p seed [ <value> ]
!p seed [ <value_a>, <value_b> ] , group:<no>

   Reinitializes the pseudo random generator. The seed passed to the
   random generator is -abs(nint(value)). If the <value> is omitted,
   the random generator will be passed the number of hundredth of
   seconds passed since midnight, essentially initializing the sequence
   at a unknown fairly random point.

   The seed may take more than one parameter, usually the compiler
   takes 12 different seeds.

   To overcome limited internal precision, a patch has been introduced
   in version 5.17.0. 
   As the random number generator takes seeds in the range from
   1 to 99999999 the internal precision that calculates the value 
   on the command line via the detour of a real valued number turned
   out to be insufficient. To ensure that an eight digit seed number
   is properly transfered to the seed initialization routine, split
   the number into two groups of four digit integers as in:
   12345678  => 1234, 5678, group:2
   The optional parameter "group" tells the SUITE to group these two 
   numbers together to the original intended eith digit no.
3  matrix

   For the user defined 1-D and 2-D matrices several command are 
   available for the usual matrix arithmetics. These are:
4  detmat
!p detmat <matrix>

   Calculates the determinant of a [n x n] matrix. Currently limited
   to dimensions 1 to 4. The result is stored in res[1]
4  invmat
!p invmat <result>, <input>

   Calculates the inverse matrix for <input> and stores the result 
   in <result>. Both matrices must be square with identical 
   dimenstions 1 to 4.
4  matmul
!p matmul <result>, <a> [, <b>]

   A generic name for several calculations. Mainly, of course, the
   standard matrix multiplications of user defined variables 
   <a> with <b>.
   Either or both of <a> and <b> may be arbitrary scalar expressions.
   The result and the input matrices may be 1-D and or 2-D 
   according to the standard rules for matrix multiplications

   Thus the command essentially provides the operations:
 
   1) Result_matrix = Scalar
   2) Result_matrix = Scalar * Scalar
   3) Result_matrix = Scalar * Matrix = Matrix * Scalar
   4) Result_matrix = Matrix
   5) Result_matrix = Matrix * Matrix

   1) and 2): Each matrix element is set to the scalar value
       Result[i,j] = scalar
   3): Each input matrix element is multiplied by the scalar
       and each result element corresponds to the input matrix
       element
       Result[i,j] = scalar * Input[i,j]
   4): The result matrix is identical to the input matrix
       Result[i,j] = Input[i,j]
   5): Standard matrix multiplication
       Result[i,j] = A[i,k] * B[k,j]

   For operations 3 and 4, both matrices must be of identical 
   shape and dimension. 
   For operation 5 the standard rule on shape and dimensions
   holds with
       Result[i,j] = A[i,k] * B[k,j]
4  matadd
!p matadd <result>, <a> [, <scalar>], <b>

   Adds two user supplied matrix variables.
       Result[i,j] = A[i,j] + Scalar * B[i,j]

   The three matrices have to be of identical shape and dimensions,
   The scalar is optional and defaults to +1.
   The result matrix may be the same variable as any of the 
   two input matrices.
4  mattrans
!p mattrans <resul<, <input>

   Calculates the transposed matrix for <input> and stores this 
   in <result>

3  set
!p set <command>,..

   This command allows to alter various program independent setting.
   Allowed values for <command> are:

4  parallel
!p set parallel {,"useomp:"["use"|"parallel"|"serial"|"off"]} 
!p              {,"nthread:"["all"|"physical"|"logical"|<number>]}

   Defines the usage of OpenMP. As of version 6.02 DISCUS_SUITE is
   compiled with OpenMP. This allows to calculate several parts of the 
   program in parallel, without user interaction. 

   useomp: "use" or "parallel" will turn the use of openMP on, 
           "serial" or "off" will turn its use off.

   nthread: "all" or "physical" will use all physical cores as threads.
            "logical" will use all logical threads, which might put two
                      or several threads onto a single physical core.
            <number> will use the user provided number of threads.

   Entry "res[1]" is set to TRUE==1/FALSE==0
   Entry "res[2]" is set to the maximum number of threads available.
   Entry "res[3]" is set to the number of physical cores.
   Entry "res[4]" is set to the number of logical cores.

   DISCUS_SUITE will check at startup how many physical and logical cores
   are available on your computer. My experience is that performance with
   openMP improves only up to the number of physical cores. Thus the 
   maximum number of parallel threads is initially limited to this number.

   See ==> 'show parallel' to get the number of physical and logical cores.

   As the parallel algorithm of OpenMP requires a bit of administrative
   overload, you might want to turn this parallel processing off if:
     The program runs in parallel with "mpiexec" (Linux/MacOS) or the
     'parallel' command at the suite level.
     This would commonly be the case if you use the "diffev" type of
     refinement.
     Since the MPI parallel processing currently uses all cores of 
     a given node, the local OpenMP parallel algorithm cannot use 
     more processors. 
4  plot
!p set plot:on
!p set plot:off
!p set plot,on
!p set plot,off

   Sets the behaviour of the KUPLOT 'plot', 'mouse' and the 
   DISCUS interactive plot with jmol.
   With the plot status 'on' images are drawn to the screen, 
   otherwise the plots are not drawn. 
   This commands allows to change the overall behaviour of lengthy
   macros that have one or several plots that you would like to turn
   off for an long calculation, especially on a remote computer.
4  prompt
!p set prompt, {"on"|"off"|"redirect"},[{"on"|"off"|"file"}, ["save"]]
4  prompt
!p set prompt, {"on"|"off"|"redirect"},[{"on"|"off"|"file"}, ["save"]]
!p set prompt, "old"

   First parameter sets the status of the PROG prompt. The default is 
   "on", i.e. PROG prompts for the next command by writing "discus > "
   (in case you run DISCUS ..). You can turn this prompt off. This is 
   useful, if you are running a long macro and do not
   want to get all the prompts written into the output. By using this
   option you can considerably shorten the output written by PROG into a
   redirected log file. If you are using PROG on a UNIX platform, you can
   start the program with redirected input by the command:

!p "prog < inputfile"

   By default, PROG will write the prompt "discus >" into the output file,
   expecting a RETURN from the keyboard. Very long lines in the output file
   will result. To avoid this situation insert the line "set output,redirect"
   as first line in the inputfile to force discus to echo the lines from file
   inputfile.

   The prompt setting "redirect" has an important side effect on macro 
   treatment. With the "redirect" setting, macros are stored internally,
   once they have been read from disk, and will be reused from memory. This
   helps to reduce unnecessary I/O, especially when you have nested macros
   inside loops. For all other settings, the internal macro storage is 
   cleared when you get back to the normal interactive mode. This allows
   you to run a macro, then modify the version stored on the disk and 
   execute the modified/corrected version.

   This second parameter  allows the user to assign where the text output
   of the program should go: "on" prints on the screen, "off" will result 
   in no output and "file" will save the output to a file progname.log 
   (e.g. discus.log in DISCUS). Note that the output of the commands
   'echo' and 'eval' will always appear on the screen. The last parameter
   allows on to save the current prompt and output settings.

   The parameter "old" allows the user to restore the setting of the 
   prompt and output. This can e.g. be used to turn the prompt off in a 
   macro and then restore the original setting after the macro is executed.
   Make sure that you saveed the desired prompt by setting the last
   parameter to "save".
4  error
!p set error , {"cont" | "exit" | "live" | "old"} [ , "save"]

   Sets the error status.

!p "cont"  PROG returns the normal prompt after the display of the error
!p         message. You can continue the input of commands.
!p         The execution of a macro file is stopped, the program continues
!p         with the regular prompt of the menu/submenu where the error occurred.
!p "exit"  PROG terminates after the display of the error message.
!p         This option is useful if you run PROG in the batch mode of your
!p         operating system. Instead of continuing with a faulty calculation
!p         PROG stops and you can immediately check the error.
!p "live"  PROG remains alive after an error is encountered. The variable
!p         "res[0]" is set to -1. The error number is written into "res[1]",
!p         the error type to "res[2]". Further error codes are written into
!p         "res[3]".
!p         With this error status, the program remains alive within a loop
!p         as well, which it does not do with the error status "cont".
!p         The program also continue to execute a macro! 
!p         It is most helpful to catch errors from the 'system' command
!p         and to allow a flexible response. 
!p "old"   Restore the last error status that was set and saved in a 
!p         previous 'set error, <value>, save ' command. 
4  debug
!p set debug, {"on" | "off"}

   This command allows the user to enable various DEBUG outputs ...
4  wait
!p set wait, {"on" | "off"}

   This command allows the user to tailor the 'wait' comand.
   The default is 'set wait, on'.
   With 'set wait, on' the 'wait' command in a macro is active.
   With 'set wait, off' the 'wait' command in a macro will be 
   ignored and the programm continues execution as if the 
   'wait' command were absent.
3  show
!p show {"error" | "parallel" | "res" | "variables"}

   The show command displays settings onto your screen. The individual
   programs discus, kuplot, diffev, mixscat all have specific parameters
   to the show command as well, see the help at the main program level
   for details.

!p "error"

   With ==> 'set error' you can define the program behavior if 
   DISCUS_SUITE detects an error. "show error" displays the current status.

!p "parallel"

   Shows if DISCUS_SUITE has been compiled with OpenMP. If OpenMP is
   active, the number of threads is shown.
   Entry "res[1]" is set to TRUE==1/FALSE==0
   Entry "res[2]" is set to the maximum number of threads available.
   Entry "res[3]" is set to the number of physical cores.
   Entry "res[4]" is set to the number of logical cores.

   See ==> 'set parallel' for options related to OpenMp
!p "res"

   Many commands produce results that are stored in the result variable 
   res[<i>]. Thise are displayed via "show res".
   The entry res[0] gives the number of entries in the result variable.

!p "variables"

   Lists the variables that have been defined, their type and their 
   current values. The command is identical to the "variable show" 
   command.   
3  sleep
!p sleep <seconds>

   This command causes the program to sleep for <seconds> seconds
!% 3  socket
!% !p socket "open",<host>,<port>
!% !p socket "close"
!% !p socket "exit"
!% !p socket "send",<string>
!% !p socket <string>
!% !p socket "transfer",<slave_var>,<expression>
!% !p socket "transfer",<slave_var>,<character expression>,<local_var>
!% 
!%    These commands connect to a program that has been started with the 
!%    "-remote" option, sees ==> "Options" for further help. 
!%    The commands will be send to the slave program where they will be
!%    executed as typed. 
!% 
!% 4  open
!% !p socket "open",<host>,<port>
!% 
!%    Opens the connection to the program running on host <host> and 
!%    listening on port <port>. The server program  must have been 
!%    started beforehand with the "-remote" option
!% 4  close
!% !p socket close
!% 
!%    Temporarily closes the connection to the slave program, which keeps
!%    running. You can open to the same program with a new socket open,<pname>.
!% 4  exit
!% !p socket exit
!% 
!%    Terminates the slave program and closes the connection. To communicate
!%    with the slave program again, you must first start this with the
!%    "-remote" option and then open the connection with 
!%    socket "open",<pname>.
!% 4  send
!% !p socket send,<string>
!% !p socket <string>
!% 
!%    The string is send to the slave program and executed as typed.
!%    Both forms are equivalent.
!% 4  transfer
!% !p socket transfer,<slave_var>,<expression>
!% !p socket transfer,<slave_var>,<character expression>,<local_var>
!% 
!%    This command transverse the value of <expression> to the slave
!%    variable <slave_var>. You must define this slave variable prior
!%    to a transfer. 
!% 4  Example
!% 
!% !p system /usr/local/bin/kuplot -remote   ! starts kuplot slave
!% !p i[0] = 4.0                             ! set local variable
!% !p socket open,localhost,3331             ! open connection
!% !p socket func r[0]**2,-2,2,0.1           ! define a function to plot
!% !p socket transfer,i[1],i[0]              ! transfer local variable
!% !p socket tit1 "%d",i[1]                  ! set plot title
!% !p socket plot                            ! display plot
!% !p socket mark 1,1                        ! change marker interval
!% !p socket plot                            ! plot again
!% !p socket send, mark 0.5,0.5              ! change marker interval
!% !p socket send, plot                      ! plot again
!% !p socket exit                            ! terminate kuplot, exit
3  stop
!p stop

   This command is active only while reading from a macro file or in
   interactive mode inside a block structure (do-loops and/or if's).

   The current macro file is interrupted and you can type commands as in the
   normal input mode. You can use the whole range of PROG commands,
   including the '@' macro command. The 'stop' commands provides a convenient
   mode to debug a macro by setting a break point at which you can check the
   value of variables or set new values, run an additional macro etc.

   To continue execution of the macro or to continue with the normal
   PROG mode, use the ==> 'continue' command.

   If included in a block structure statement (do-loops and/or if's) in
   both, macro and interactive mode, the program continues reading all
   statements that belong to the block structure. During execution of the
   structure, PROG interrupts this execution if it encounters a 'stop'
   command. You can issue any PROG command except further do or if commands.

   To continue execution of the structure or to continue with the normal
   PROG mode, use the ==> 'continue' command.
3  system
!p system <com>
!p system "string%dstring",<integer expression>
!p system "string%fstring",<float expression>

   Executes the single shell command <com>.
   If the command string is enclosed in "", you can place integer and
   real format specifiers "%d" "%f" which are then substituted by the
   corresponding values. 
   The shell command <comm> may be placed in front of the double
   quotation marks.

   Example
   i[0]=10
   system "ls %d.*"
   system ls "%d.*"

   This would list all files called 10.*
3  timer
!p timer reset
!p timer {"mode:start" | "mode:stop" }

   Optional parameters:
!p {"type:cpu" | "type:wall" }   
!p number:<value>
!p {"output:screen" | "output:none"}

   A general timer command.
   "timer mode:start" 
   will start timer number 1 counting CPU time.

   To get the elapsed time use:
   "timer mode:stop"
   This will print the elapsed CPU time to the screen and 
   place the time into res[1]. If the timer had not been started, you 
   get an error message. 

   Options:
   With the optional parameter "type:wall" the Wall clock time is measured.
   With the optional parameter number:<value> you may start another timer,
   keep in mind that you will have to stop the correct timer number later on.
   Several timers can be started.

   To suppress the output, add "output:none", the result variable is still set.

   "timer reset" clears all timers
3  wait
!p wait [{"return" | "input" [,<prompt>] }]

   This command waits for user input. 
   Without a parameter or with "return", the program waits for a 
   simple <RETURN>.

   If the parameter is "return", you can type "stop" and then press
   enter/return to stop the execution of the current macro. The program
   will return to the regular interactive session within the section 
   menu or submenu at the current point of execution.

   If the first parameter is "input", the program expects the user to enter
   one or more real numbers or expressions. The optional <prompt> can be 
   used to ask the user to input the expressions. This is especially 
   helpful if the prompt has been turned of by ==> set prompt,off.
   The number of expressions entered by the user is stored in the variable
   res[0] and the results of the expressions in res[i].

   This command allows to write interactive macros, demo macros
   and tutorials.

   With the command 
!p set wait, {"on" | "off"}
   you can toggle the active state of the wait command on off.

   The default is 'set wait, on'.
   With 'set wait, on' the 'wait' command in a macro is active.
   With 'set wait, off' the 'wait' command in a macro will be 
   ignored and the programm continues execution as if the 
   'wait' command were absent.
3  umount
!p umount <drive>
!p umount <drive:>

   This command is relevant for the Windows version only. 
   It disables access to removable drives like "F:" etc. 
   Unfortunately at the moment The Linus Subsystem does not 
   perform an automount / dismount. 
   If a removable drive had been mounted either by the ==> 'mount' 
   command or the ==> 'cd' command, Windows will lock the drive 
   and you cannot remove it properly. As Discus does not know 
   if you do not need the drive any longer, you have to unmount the 
   drive explicitly.

   A mount is performed automatically if you use the ==> 'cd' command.

   See also ==> 'mount'
3  variable
!p variable {"integer"|"real"},<name> [,<initial_value>] [,dim:[d1,d2]]
!p variable {"character"},<name>
!p variable show
!p variable reset
!p variable delete {,"all"| <name>..]

   The programs that are part of the DIFFUSE suite offer predefined
   variables i[*] and r[*]. These are an integer and a real 
   array, respectively, into whose element you may store appropriate
   values. 
   In order to enhance readability of a macro, you can define your
   own variable names by the use of this command. The variable may
   either be an integer or a real variable. There is no predefined
   syntax for the variable names. Optionally you can initialize the
   variable to <initial_value>, default is zero. These user defined
   variables may be used just as the system integer and real 
   variables i[*] and r[*]. 
   Character variables may be used to hold a string of text.

   The variable names may only consist of alphanumerical characters
   including the underscore "_".
   "Real" and "Integer" variables my optionally be declared as 
   one or two dimensional arrays. Specify the dimension as:
   dim:[12]  for a 1-D array of length 12
   dim:[3,3] for a 2-D array of length 3x3
   Array indices start at 1.
   Presently character variables are single value variables.
   Several commands exist for matrix algebra. See the help entry
   ==> 'matrix' for a summary of these commands.

   Several system variable exist that are read only. Several of 
   these refer to the refinement section DIFFEV. These variables 
   all start with "REF_". See the DIFFEV on-line help and manual
   for further details.

   If the first command parameter is "show" the program displays a
   list of user defined variables and their current values.
   Refer to the help entry "expressions" for further help.

   Both, the "reset" and the "delete, all" parameters specify that
   the variable list is to be cleared of all user defeined variables.
   Only the system variables remain.

   Alternatively, the "delete, <name>" parameters allow you to delete 
   an individual variable.

   Examples:
!p variable  int,alpha,90
!p variable  int,beta
!p variable  real,diff
!p beta = 94
!p diff = alpha - beta
!p eval diff

!p variable real, vector, dim:[3]
!p vector[2] = 3.1415
!p evaluate vector[3]

!p variable real, array, dim:[4,10]
!p array[4,5] = 3.1415
!p evaluate array[1,8]


!p variable  character,string
!p variable  character,line
!p string = "abcdefg"
!p line   = "%3c",string(2:4)
!p var show

   Variable names that are part of intrinsic functions, keywords like
   "do", "elseif", "eq", and program specific variables like "r" and "i" 
   are not allowed. Thus a variable called "a" is illegal, since it
   is part of the intrinsic function "asin".

   Internally the program sorts the variable names by length and in
   inverse alphabetical order. This sorting has no serious consequence
   for the user other than finding the variable in the printed list
   when using the 'variable show' command. 

   A few predefined variables exist, their names are capitalized:
   PI  3.1415...
   REF_GENERATION  Current generation number as set by DIFFEV
   REF_MEMBER      Current population size   as set by DIFFEV
   REF_CHILDREN    Current child population size as set by DIFFEV
   REF_DIMENSION   Current Number of parameters a set by DIFFEV
                   If the value is changed, you can store more
                   values in ref_para[], but this does NOT change
                   the actual dimension pop_dimx that DIFFEV uses.
   PROGRAM         Tells you in which section you are possible 
                   values are SUITE=0, DISCUS=1, DIFFEV=2, KUPLOT=3 
   STATE           Tells you whether this is the TOP=0 level, a
                   SECTION=1 or a BRANCH=2.
   MPI             Was the program started with MPI ?
                   MPI_ON=1, MPI_OFF=0
   MPI_FIRST       Is this the first call to DIFFEVs ==> 'run_mpi'
                   command with the current GENERATION? FALSE=0 TRUE=1
3  errors

   The program has been written such that it should handle almost
   any typing error when giving commands and hopefully all errors
   that result from calculation with erroneous data. When an error
   is found an error message is displayed that should get you back
   on track. See the manual for a complete list of error messages.
   In this part we refer to the program you are using as DISCUS for
   convenience.

   The error messages concerning the use of the command language
   are grouped in the following categories:

!p COMM   Command language errors
!p FORT   Fortran interpreter errors
!p I/O    Errors regarding input/output
!p MACR   Errors related to macros
!p MATH   General mathematical errors

   Each error message is displayed together with the corresponding
   category <cccc> and the error number <numb> in the form:

!p ****CCCC****message                    **** numb ****

   In the default mode DISCUS returns the standard prompt and you can 
   continue the execution from this point. You can set the error status
   to "exit" by the ==>'set' command. In this case DISCUS terminates 
   if an error is detected. This option is useful to terminate a faulty
   sequence of commands when running DISCUS in the batch mode of your
   operating system.

4  comm

   Command language errors
   These messages describe illegal usage of the command language, such as
   unknown commands, improper numbers of parameters.

5  -1
   DISCUS directory not defined

   The environment variable DISCUS_DIR was not defined. Check the chapter 
   on installation for your platform for the appropriate definition. 
5  -2
   Command parameter has zero length

   On the command line you probably have a typing error like two 
   comma following each other without significant values in between, 
   or the first non blank character after the command is a comma.
5  -3
   Could not allocate arrays

   The program has to allocate arrays, but received a error message.
   Does your computer have enough available memory space?
5  -5
   Error in operating system command

   The operating system/shell returned an error message. Check the 
   appropriate system manuals for details. 
5  -6
   Missing or wrong parameters for command

   Either the command needs more parameters than were provided, or the 
   parameters are incorrect. Check the number and type of parameters. Is 
   the sequence of numerical and character parameters correct? 
5  -8
   Unknown command

   The command interpreter read an unknown command. Check the spelling 
   of the command or check, whether this command is allowed at the current
   sublevel. 
5  -11
   Error in subroutine

   More or less a system error message, ignore this message. 
5  -17
   Too many parameters

   More parameters have been provided than are required by the command. 
   Check the number, and type of parameters supplied, or the occurrence 
   of additional ','. 
4  fort

   Fortran interpreter errors
   These messages describe erroneous mathematical calculations and
   improper usage of control structures (do,if, ...).

5  -1
   Nonnumerical Parameters in expression

   The interpreter found a nonnumerical string where a number is expected. 
   If an intrinsic function or a variable was intended, check for spelling
   or missing parentheses. 
5  -2
   Unknown Variable

   The expression contains a reference to an unknown variable. Check the 
   spelling of the variable. Chapter 3.7.1 of the manual and the help
   entry "variables" contains a list of allowed variables. 
   Check whether the variable is a read-only variable and was used on the 
   left side of an expression. Some of the variables associated with
   microdomains are read-only depending of the circumstances! 
5  -3
   Unknown intrinsic function

   The expression contains a reference to an unknown intrinsic function. 
   Check the spelling of the function. Chapter 3.7.4 of the general part
   in the manual and the help entry "functions' contain a complete list
   of the allowed intrinsic functions. 
5  -4
   Division by zero'

   An attempt was made to divide by zero. Check the value of the argument 
   and correct the algorithm that calculates the argument. 
5  -5
   Square root of negative number

   An attempt was made to calculate the square root of a negative argument. 
   Check the value of the argument and correct the algorithm that calculates 
   the argument. 
5  -6
   Missing or wrong Parameters for command

   Either the function or variable referenced needs more parameters than 
   were provided, or the parameters are incorrect. Check the number and 
   type of parameters. Is the sequence of numerical and character parameters 
   correct? 
5  -7
   Argument for asin,acos greater 1

   An attempt was made to calculate asin or acos with an argument greater 
   than 1. Check the value of the argument and correct the algorithm 
   that calculates the argument. 
5  -8
   Index outside array limits

   The index supplied for the variable is outside the limits of this
   variable. Check the general part for the dimensions of the variables. 
5  -9
   Number of brackets is not matching

   The number of opening and closing brackets "[" and "]" does not match
   or is illegally nested with parentheses "(", ")" or other operators.
   Check the string used in the expression and correct it following the
   FORTRAN rules.
5  -10
   Index for array element is missing

   You have used a string like "i[]", where the opening and closing 
   brackets do not contain any expression.
   Check the string used in the expression and correct it following the
   FORTRAN rules.
5  -11
   Number of parentheses is not matching

   The number of opening and closing parentheses "(" and ")" does not match
   or is illegally nested with brackets "[", "]" or other operators.
   Check the string used in the expression and correct it following the
   FORTRAN rules.
5  -12
   Expression between () is missing

   You have used a string like "()", where the opening and closing 
   parentheses "(" and ")" do not contain any expression.
   Check the string used in the expression and correct it following the
   FORTRAN rules.
5  -13
   Wrong number of indices for array

   The number of indices given for the entered parameter is wrong.
   Check the help entry 'variables' for the proper number of indices.
5  -14
   Index of DO-loop counter is missing

   Here the index for the loop counter of a do-loop is missing. Check
   the online help for the correct syntax of such loops.
5  -15
   Too many commands

   The program stores all commands within a control block in an array. 
   The maximum number of commands that can be stored in this array is 
   given by the parameter MAXCOM in file "doloop.inc". The macro or run
   used more commands than currently allowed by this parameter. 
   Rewrite the macro or list of commands such that less commands are 
   sufficient, or change the value of the parameter and recompile the 
   program. 
5  -16
   Too deeply leveled (do,if) construction

   The program stores all commands within a control block in an array. 
   The maximum number of levels for this array is given by the parameter 
   MAXLEV in file "doloop.inc". The macro or run used more levels than 
   currently allowed by this parameter. 
   Rewrite the macro or list of commands such that less levels are 
   sufficient, or change the value of the parameter and recompile the 
   program. 
5  -18
   Unresolvable condition

   An error occurred while trying to calculate the value of an arithmetic 
   or logical expression. Check that there is no illegal operation /(division 
   by zero .../ no typing errors, all parentheses are properly matched. 
5  -19
   Illegal nesting of control commands

   Do  loops and/or if constructions have been nested with overlapping 
   segments, missing enddo or endif statements or similar causes. Check 
   for spelling errors on the control statements, and that each control 
   statement is properly terminated by a corresponding enddo or endif 
   statement that is not enclosed within another control block. 
5  -20
   Illegal argument for ln(x) function

   The argument for the ln must be positive, larger than zero. Check the
   value of the argument or the value of the expression that serves as 
   argument
5  -21
   Missing ' while comparing stings

   An expression of the form ('string' .eq. 'line') was used, where
   one of the quotation marks has been omitted. Check the respective
   line.
5  -22
   Maximum number of real variables defined

   DISCUS can define a fixed number of user variable names. The maximum
   number allowed for your installation id displayed by the command
   variable show
   If you would like more user definable variable names, change
   the value of the parameter VAR_REAL_MAX in "config.inc"
5  -23
   Maximum number of int. variables defined

   DISCUS can define a fixed number of user variable names. The maximum
   number allowed for your installation id displayed by the command
   variable show
   If you would like more user definable variable names, change
   the value of the parameter VAR_INTE_MAX in "config.inc"
5  -24
   Variable is not defined

   You tried to use a name within an expression that was not recognized
   as a user defined variable name. Check the spelling of the line.
   Was an intrinsic function to be used, or was the variable not
   defined? See the ==> 'variable' entry in the help menu regarding
   the definition of variables.
   You will also get this error message if you tried to define a 
   variable using the command:
   variable real,dummy=3
   The equal sign "=" may not be used as part of a variable name. If
   you intend to provide an initializing value, use the command as:
   variable real,dummy,3
5  -25
   Variable name contains illegal characters

   You tried to define a variable name that contains characters other
   than letters, numbers or the underscore "_".
   The variable names are restricted to alphanumerical characters and
   the underscore "_".
5  -26
   Variable name contains illegal characters

   Variable names may consist only of letters (lower and upper case),
   numbers and the underscore "_". Check the spelling of the variable
   you tried to define with respect to these rules.
5  -27
   Function with wrong number of arguments

   You called an intrinsic function with the wrong number of arguments.
   Check the listing of intrinsic functions for the valid number of
   arguments and the compare to the input line you had typed.
5  -28
   Too deeply leveled break command

   Illegal use of the break command. The parameter on the break command 
   signals how many block structure levels are to be exited. Check the 
   value of this parameter with regard to the nesting of do-loops and 
   if-blocks. 
5  -29
   Character substring out of bounds',        & !-29  ! fortran

   In a statement like 
   variable character, line
   line = 'abcde'
   echo "%c",line(1,5)
   The first index is  less than one, or the second index is larger than
   the number of characters in the strin, or the second index is less
   than the first.
5  -30
   Right quotation mark missing in format'

   A statement like 
   echo " text " 
   is missing the right quotation mark.
5  -31
   Incomplete (do,if) statement

   Some part of a ==> 'do' or ==> 'if' statement is missing.
   Check the line for missing part or typing errors. 
5  -32
   Variable name is already defined

   The variable that you want to define is already in use as another
   data type. 
5  -33
   Variable in use; cannot initialize value

   A variable name can be redifined as identical data type, in order 
   to be able to use a macro with a variable definition inside a loop.
   You may, however, not provide an initialisation value, as this would
   override the current value.
5  -34
   String has length zero',                   & !-34  ! fortran

   A statement like
   echo ""   or
   line = ''
   occured in which the single or doluble quotation marks enclose a 
   zero length string.
4  i/o

   Errors related to input / output
   An error occurred while attempting to read/write from a file

5  -1
   File does not exist

   DISCUS could not find the file. Check the spelling and the path. 
5  -2
   Error opening file

   DISCUS could not open a file. The file might be in use by another process. 
5  -3
   Error reading file

   An error occurred while  DISCUS was reading a file. Check whether the 
   contents of the file is correct. 
5  -4
   File already exists

   An attempt was made to overwrite an existing file. Rename or delete 
   the file in question. 
5  -5
   No such entry in online help

   You have tried to obtain help for a string that does not have a matching
   entry in the help file. 

   Check the spelling of the string. Are you at the right sublevel?
   Use the '?' command to get a listing of available help entries.
5  -6
   Unexpected end of file

   DISCUS has encountered the end of a file, but is still expecting data.
   Check the file(s) involved, to see whether the data are complete or
   whether erroneous data are present.
5  -7
   Learning sequence already in progress

   You have tried to start a learning sequence by ==>'learn' without 
   closing the active learning sequence. Close the current learning
   sequence by ==> 'lend' before starting to record a new macro.
5  -8
   Nothing learned - no macro written

   You did not type any commands since the ==>'learn' command. No commands
   are written to the macro file.
   You need to give at least one command before closing a learn sequence.
5  -9
   Error reading user input

   An error occurred while reading the last input. 
   Does the string contain any characters where a number is expected, or
   any control or escape sequences.
5  -10
   IO stream already open

   The command 'fopen' was issued while there was already a file open.
   Close the currently open file with 'fclose'.
5  -11
   No IO stream open to close

   The command 'fclose' was issued, but there is no open file.
5  -12
   Error writing to file

   An error occurred when reading a file with 'fget'. Check the file
   for nonnumerical values and check that the number of columns is
   equal or larger than the number of arguments of 'fget'.  

5  -13
   I/O stream number outside valid range

   The I/O stream number must be larger than 0 and less than the value
   defined in macro.inc, which usually is 10.

5  -14
   Filename has zero length

   You tried to open a file with ==> 'fopen', whose file name is of
   length zero.
   Check the statement for the missing filename, or an additional comma.
!% 5  -15
!%    No socket connected
!% 
!%    Apparently you tried to use a ==> 'socket' command prior to opening
!%    a connection to the remote computer. 
!%    Use a 'socket open' command first.
!% 5  -16
!%    Could not resolve hostname for socket
!% 
!%    The hostname to which you want to connect could not be resolved into
!%    an IP address. 
!%    Check the host name for typing errors and the Internet access of your
!%    computer.
!% 5  -17
!%    Could not grab socket
!% 
!%    Internal socket debug message.
!% 5  -18
!%    Could not open socket connection
!% 
!%    Internal socket debug message.
5  -19
!%    Problem sending to socket
!% 
!%    Internal socket debug message.
!% 5  -20
!%    Problem receiving from socket
!% 
!%    Internal socket debug message.
!% 5  -21
!%    Received null string from socket receive
!% 
!%    The remote computer send back an answer of zero length. Apparently 
!%    the connection was terminated prematurely.
!% 
!%    Try to connect again.
!% 5  -22
!%    Socket accept problem
!% 
!%    Internal socket debug message.
!% 5  -23
!%    Scocket: Rejected connection
!% 
!%    Internal socket debug message.
!% 5  -24
!%    Socket bind problem
!% 
!%    Internal socket debug message.
!% 5  -25
!%    Socket listen problem
!% 
!%    Internal socket debug message.
5  -26
   Second parameter must be >= first Param.

   You tried to read a substring with a line like
   echo "%c",line(1:5)
   but the second parameter , here a "5" was less than the first, here a "1".
   The second parameter must be equal to or larger than the first in order 
   to specify a valid substring.
4  macro

   Errors related to macro
   These messages describe situations that result from missing macrofiles,
   missing macro parameters ...

5  -1
   Too many macro parameters given

   The number of parameters given on the macro command line is higher
   than allowed in your installation. The maximum number of parameters
   allowed is defined by the parameter MAC_MAX_PARA in the file 
   macro.inc.
   Check the macro command line for any additional "," or rewrite the
   macro to use less parameters. If necessary adjust the value of the
   parameter MAC_MAX_PARA and recompile the program.
5  -12
   Macro not found

   The file given on the @<name> command does not exist. Check the 
   spelling of <name> and the path.
5  -13
   Macro filename is missing on the command line

   The command '@' to execute a macro was called without any macro 
   file name. The file name must start immediately after the "@".
   Check the '@' command for completeness and blanks after the "@".
5  -35
   Too deeply leveled macros

   The maximum level at which macros may be nested is defined in the 
   file macro.inc in the parameter MAC_MAX_LEVEL. Check the nesting of 
   macro file for the level of nesting or possible recursive nesting
   without proper termination. Rewrite the macros to use less nesting,
   or change the value of the parameter and recompile the program. 
5  -36
   Unexpected EOF in macro file

   When DISCUS finds a '@' command inside a macro, it stores the current 
   macro name, the line number inside the current macro and closes the 
   current macro file. After completion of the new macro, the previous 
   macro is read again up to the position stored. The error message 
   is displayed when an end of file is found before the position is 
   reached. Check whether the macro file was damaged, or accidentally 
   deleted during execution of the nested macro. 
5  -41
   Not enough macro parameters given

   DISCUS read a parameter number inside a macro file that is higher
   than the number of parameters given on the command line of the macro.
   Check the parameters inside the macro for correct numbering and
   spelling. Check the number of parameters supplied on the command and
   check whether any "," is missing between parameters. 
