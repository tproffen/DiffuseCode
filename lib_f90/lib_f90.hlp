2  Command_language

   All commands consist of a command verb, optionally followed by one
   or more parameters. All parameters must be separated from one
   another by a comma ",". There is no predefined need for any specific
   sequence of commands.

   Commands are case sensitive, all commands and alphabetic parameters MUST
   be typed in lower case letters.

   Only the first four letters of any command verb are significant, all
   commands may be abbreviated even further. At least a single space is
   needed between the command verb and the first parameter. No comma is
   to precede the first parameter. The command verb itself MAY NOT be
   preceded by any blanks.

   All text in an input line that follows a "#" or "!" is treated as
   comment and ignored.

   The word PROG in this part of the help section is to be replaced
   by the name of the program you are using (e.g. DISCUS).

   Further help topics are:

3  Options
!b program [-debug] [-remote] [-port=p] [-access=ip] [macro.mac]
!b program -macro <macro.mac>[ <par1> [ <par2> ...]]

   All programs allow the following command line parameters. The flag
   "-debug" starts the program in debug mode. This is the same as using
   the command "set debug,on". The switch "-remote" starts the program
   in remote control mode. In this case the commands are send to the
   program through a socket. In this case the switch "-port' allows one
   to specify the port, the program will be listening on. Port numbers
   should be larger than 1024. The switch "-access' allows one to specify
   from which host connections will be accepted. The default is 
   'localhost'.

   See file "remote.f" for an example how to remote control the 
   applications from another program. Note that the program will not 
   accept input from the keyboard when in remote control mode. 

   All other command line arguments are interpreted as macro files
   and will be executed at startup. These macros may not rely on
   parameters to be given on the command line.

   If a macro is to be executed that takes 1 or more parameters, use
   the "-macro" option. Note that this option is mutually exclusive
   to all other options. The first command line argument after  the 
   '-macro' option it the macro name, all further optional command 
   line arguments are taken as macro parameters. These have to be 
   seperated by one or more spaces. 
   Parameters that need to contain spaces must be enclosed in single 
   or double quotation marks.
   -macro test.mac 1 2 3
   This is the same as @test.mac 1,2,3

   -macro test1.mac '1 + 2 + 3'
   This is the same as @test1.mac 1 + 2 + 3
3  #
!b #<comment>

   Any line beginning with a "#" is regarded as comment.
3  @
!b @<filename> [<argument> ...]

   Any list of valid commands can be written to an ASCII file and
   and indirectly by the command:

!p prompt > @<name>

   The commands may start in with leading blanks to help readability of 
   the macro file. The commands are executed as typed.
   Macro files may call other macro files. This is not a call in
   the sense of calling a function.
   All variables are identical at all levels of macro file nesting.

   Macro files can be written by any editor on your
   system or be generated by the ==> 'learn' command. 'learn' starts to
   remember all the commands that follow and saves them into the file
   given on the 'learn' command. The learn sequence is terminated by
   the 'lend' command. The default extension is ".mac"

   Optionally arguments can be listed on the command line. These arguments
   will replace the formal parameters inside the macro. The formal
   parameters must be given as "$1", "$2" ... The string <argument> will
   replace the string "$1". "$1" is the first argument on the command line,
   "$2" the second and so on. If there are not enough command line arguments,
   an error message is displayed.
   The parameter "$0" contains the number of parameters listed on the line
   that called the macro. If no parameters were given this value will be 
   zero.

   The prompt setting ==> 'set prompt,"redirect"' has an important side 
   effect on macro treatment. 
   With the "redirect" setting, macros are stored internally,
   once they have been read from disk, and will be reused from memory. This
   helps to reduce unnecessary I/O, especially when you have nested macros
   inside loops. As a side effect, if a macro is modified on the disk, 
   a further "@macro.mac" will not read the modified version but will
   continue to use the internaly stored version.

   For all other settings, the internal macro storage is 
   cleared when you get back to the normal interactive mode. This allows
   you to run a macro, then modify the version stored on the disk and 
   execute the modified/corrected version.
3  =
!b <variable> = <expression>

   The expression on the right of the equal sign is evaluated and its result
   stored in variable <variable>.
3  input
!b Input editing functions

   If the program was compiled with -DREADLINE, the following basic
   editing functions are available at the program prompt:

!p   ^A               : moves to the beginning of the line
!p   ^B               : moves back a single character
!p   ^E               : moves to the end of the line
!p   ^F               : moves forward a single character
!p   ^K               : kills from current position to the end of line
!p   ^P or arrow up   : moves back through history
!p   ^N or arrow down : moves forward through history
!p   ^H and DEL       : delete the previous character
!p   ^D               : deletes the current character
!p   ^L/^R            : redraw line in case it gets trashed
!p   ^U               : kills the entire line
!p   ^W               : kills last word

   Furthermore you can move within the line using the arrow keys.

!b NOTE:

   If you redirect the input for executed PROG using 'prog < infile' you
   MUST use the command 'set prompt,off' or 'set prompt,redirect' in
   the first line to avoid that the program 'hangs' at the end of the
   file. (-> set prompt)
3  break
!b break <levels>

   The 'break' command stops the execution of the current block structure
   and advances to the next command following the block structure.
   With <levels> equal to 1 only the current block structure is interrupted,
   with any higher number the <levels> innermost block structures are
   interrupted. The 'break' command can be used only inside a block structure.
3  cd
!b cd [<directory>]

   This command allows one to change the current working directory
   (may not be available everywhere). If the command is called with
   no parameters, the current working directory is shown.
3  continue
!b continue [ "prog" ]

   This command is effective only while PROG is in the interrupted
   macro mode or inside interrupted do-loop or if-statements, which serves
   as a debug mode for lengthy macros or block structures
   Make sure you have returned to the same sub menu before you continue!

   Without parameters PROG resumes the execution of a macro or block
   structure in the line following the 'stop' command. If you
   had started another macro while debugging a macro, and this new macro
   contained a 'stop' command as well, the 'continue' command will run
   the remaining lines in the new macro and then stop again at the position
   of the 'stop' command in the outer macro.

   By providing the 'prog' parameter, PROG immediately interrupts all
   macros and returns to the normal prompt.
3  do
   Loops can be programmed with the 'do' command. The command may take
   the  following forms:
!p do <variable> = <start>,<end> [,<increment>]
!p   <commands to be repeated>
!p enddo

   Here loops may contain constants or arithmetic expressions
   for <start>, <end>, and <increment>. The internal type of the
   variables is real. The loop counter is evaluated from
   (<end> - <start>) / <increment> =1 . If this is negative, the loop
   is not executed at all.

!p do while (<logical expression>)
!p   <commands to be repeated>
!p enddo

   These loops are executed while <logical expression> is true.
   Thus, they may not be executed at all.
!p do
!p   <commands to be repeated>
!p enddo until (<logical expression>)

   These loops, however, are always executed once, and repeated
   until <logical expression> is true.
   If an error occurs during execution of the loop, the loop is
   interrupted.
3  echo
!p echo [<string>]
!p echo ["string%dstring",<integer expression>]
!p echo ["string%Dstring",<integer expression>]
!p echo ["string%fstring",<float expression>]
!p echo ["string%Fstring",<float expression>]
!p echo ["string%cstring",<character expression>]

   The string <string> is echoed to the default output device as typed.
   This command serves as a marker inside long macro files. It gives the
   user a chance to include easy to find messages in order to follow
   lengthy or nested structures.

   The alternative command format allows to echo formatted strings to the
   screen. Each "%d" is replaced by the value of the corresponding
   parameter. The sequence of "%d" corresponds to the sequence of the
   integer parameters, "%f" stands for parameters of the type real.

   The value of a numerical expression between the "%" and the "d"
   determines the width of the integer field that is printed. 
   In the case of a floating variable two expressions separated by
   a decimal point specify the width and the number of decimal
   digits that are printed.

   The capital forms "%D" and "%F" will fill leading spaces with zeros.

   A character format descriptor "%c" or "%Nc", with N an integer 
   number, describes a string of characters.

!p Examples
!p echo ">%3d<",44            produces :  > 44<
!p echo ">%1+2d<",44          produces :  > 44<
!p echo ">%3D<",44            produces :  >044<
!p echo ">%5.1f<",44.1        produces :  > 44.1<
!p echo ">%2**2+1.1f<",44.1   produces :  > 44.1<
!p echo ">%c<",'bla'          produces :  >bla<
!p echo ">%5c<",'bla'         produces :  >  bla<
3  eval
!b eval <expr> [, <expr> ...]

   Evaluates the expression(s) and displays the result(s). The result is not
   stored, this command is for interactive display only.
3  exit
!b exit

   Terminates the program and gets you back to your shell.
3  expressions

   Arithmetic expressions can be evaluated in a FORTRAN style.
   Character expressions are used to assign a string of characters to 
   a variable or filename.

4  Arithmetic expressions:

   Five basic operators are defined:

!p "+"  Addition
!p "-"  Subtraction
!p "*"  Multiplication
!p "/"  Division
!p "**" Exponentiation

   The usual hierarchy of operators holds.
   The parts of the expression can be grouped with parentheses "(",")" in
   order to circumvent the standard hierarchy
   Several intrinsic functions have been defined, see "functions" for a
   full listing.

   Examples of valid expressions are:

!p 1
!p 1+3*(sin(3.14*r[1]))
!p x[1]*0.155
!p asind(0.5)

4  Character expressions

   A character expression is signaled by a pair of " ". The content may
   be a just a simple string of characters or additional format 
   specifiers that are replaced by the value of a variable.

!p variable character,string
!p variable character,line
!p string = "abcdefgh"
!p line   = "%4c",string(2:5)
!p line   = "%c %c",string(1:2),string(7:8)
!p line   = "Number: %3d",4
!p line   = "Number: %3.1f",4.1
!p line   = string          ! Both commands work, 
!p line   = "%c",string     ! this is the prefered style
!p line   = "%c",fdate(0)   ! See ==> functions for a list of 
                            ! character functions
   Within an ==> 'if' construction you may also specify a character
   expression in the form:

!p if( '"%2c",string(3:4)' .eq. 'cd' ) then

   An expression (M:N) refers to the substring from the M's to the N's
   character.

4  Format specifiers

   In filenames ==>"filename" or character expressions format specifiers
   are used to write the value of numerical or character variables into
   the corresponding string. These format specifiers may be:

!p %d      writes a decimal/integer number, the number of digits 
!p         depends on the numerical value of the number
!p %D      writes a decimal/integer number, the number of digits 
!p         depends on the numerical value of the number
!p %3d     writes a decimal/integer number that fills 3 digits
!p %3D     writes a decimal/integer number that fills 3 digits,
!p         leading blanks are filled with zeros
!p         Any width larger than the number of digits required is allowed

!p %Md     writes a string M digits wide. M may be omitted.
!p         M may be an integer expression.
!p         d or D are allowed, D give leading zeros

!p %f      A floating/real number is written flushed left into a 
!p         character string of 8 digits
!p %F      A floating/real number is written flushed left into a 
!p         character string of 8 digits
!p %12.3f  A floating/real number is written flushed right into a
!p         character string of 12 digits. 3 digits are used for the
!p         fractional part. 
!p %12.3F  A floating/real number is written flushed right into a
!p         character string of 12 digits. 3 digits are used for the
!p         fractional part. Leading blanks are filled by zeros.

!p %M.Nf   writes a string M digits wide. N may be omitted.
!p         M and N may be integer expressions.
!p         f or F are allowed, F give leading zeros

!p %c      A character string is written, the width depends on the input
!p         variable
!p %5c     A character string of 5 characters is written.

   Examples

!p variable character,string
!p variable character,line
!p string = "abcdefgh"
!p line   = "%c",string     ==> "abcdefgh"
!p line   = "%4c",string(1:4)     ==> "abcd"
!p line   = "Hallo %c",string(2:4)    ==> "Hallo bcd"
!p line   = "Number %5d",1234         ==> "Number  1234"
!p line   = "Number %5D",1234         ==> "Number 01234"
!p line   = "Float  %8.3f",3.1415     ==> "Float     3.141"
!p line   = "Float  %8.3F",3.1415     ==> "Float  0003.141"
3  filenames
   Usually, file names are understood as typed, including capital
   letters. Unix operating systems distinguish between upper and lower
   case typing !

   Additionally (integer) numerical input can be written into the
   filename. The syntax for this is:

!p "string%dstring",<integer expression>
!p "string%fstring",<real expression>
!p "string%cstring",<character expression>

   The file format MUST be enclosed in quotation marks. The position of
   each integer must be characterized by a "%d". The sequence of strings
   and "%d"'s can be mixed at will. The corresponding integer expressions
   must follow after the closing quotation mark. If the command line
   requires further parameters (like "addfile" for example) they must
   be given after the format-parameters.
   The interpretation of the "%d"'s follows the C syntax. Up to 10 numbers
   can be written into a filename.

   Refer to the help entry "expressions" for further help.

   Examples:
!p 1)
!p i[5]=1
!p outfile a1.1
!p outfile "a%d.%d",1,1
!p outfile "a%d.%d",4-3,i[5]
!p outfile "a%1.1f",1.1

   All the above examples will result in the file name "a1.1".

!p 2)
!p do i[1]=1,11
!p ...
!p outfile "data%d.calc",i[1]
!p ...
!p enddo

   The output is written to the files "data1.calc" through "data11.calc"
3  fclose
!b fclose {<number>|"all"}
 
   This command closes a file that was opened with 'fopen <number>' or
   closes all open files. If this
   command is not used before exiting the program, data might be lost !
3  fend
!b fend <number>,{'continue'|'error'}

   This command determines the reaction to an unexpected end of file
   while reading data from input file <number>.
   If the parameter is set to "continue", the program will set the variable
   res[0] to -1 and continue the macro. If you repeat the  ==> 'fget'
   command, the program will again set res[0] to -1 and will not result 
   in an error. In order to catch and EOF, you have to evaluate the 
   value of res[0] each time the 'fget' command is executed.

   If the parameter is set to "error", the program will stop reading
   data from the input file and terminate the macro with an error 
   message. The value of res[0] remains undefined.

   The default condition at program start is "error"
3  fexist
!b fexist <file>

   This command checks the existence of the specified file <file>. The
   result is written on the screen and returned via the res[] variables.
   If the file exists, res[1] is 1, otherwise it is 0. The variable
   res[0] returns the number of parameters, here 1.
3  fformat
!b fformat <nc>,<format>

   This command allows one to specify a FORTRAN style format string
   <format> to be used for column <nc>. The default is free format,
   which can be selected using the character * as format string. If 
   the command is called with no parameters, the current settings are
   displayed on the screen. Note that an unsuitable format might 
   result in a conversion error and *** being written to the file !

!p Example: fform 1,F7.3
3  fget
!b fget <number>,<p1>,<p2>,..

   This command allows the user to read data from a file that had been 
   opened with 'fopen <number>. If no parameters are given, a line is
   read, yet its content is ignored and the line gets skipped.
   Otherwise the read numbers will overwrite the contents of the 
   specified variables.
   The values in the input file must be separated by a blank or a comma.
   This means that to read a set of words in "This is a sentence", you
   will have to read this into 4 character variables.

   Note that a 'fget' command that does not run into an unexpected 
   end of file sets the value of res[0] to zero!

   Example: 
   variavle character, str_a
   fget 1, r[2],i[2]
   fget 1, r[2],str_a,i[2]
3  fopen
!b fopen <number>,<file> [,{"append" | "overwrite"}]

   This command allows the user to open a file for reading and writing
   using the commands 'fget' and 'fput'. The first argument is the number
   of the io_stream. You can open several files at once, the exact value
   depends on the value of the variable MAC_MAX_IO in file "macro.inc".
   The second argument is the file name. The default is that existing 
   files will be overwritten if 'fput' is used. Alternatively one can 
   append data to a file by specifying the optional parameter "append".
3  fput
!b fput <number>,<p1>,<p2>, ..

   This command allows one to write data to the file that had been opened
   by 'fopen <number>'. The parameters <pi> can either be variables and
   expressions or simple text enclosed in single quotes. If no parameters
   are given, an empty line is written.
   In order to mix character variables or character functions and numbers,
   the first parameter must be a format descriptor in double "".

!p Examples:  fput 1, i[1],sqrt(1.0+i[1]*0.01)
!p            fput 1, 'Current value of i[1] : ',i[1]
!p            fput 1, "%c %d",'Current value of i[1] : ',i[1]
!p            fput 1, "%c",fdate(0)
3  fsub
!b fsub <number>,[<left>,<right>]

   The command allows you to limit the string from which 'fget' reads the
   data from file <number>. Data will only be read columns <left> to <right>.
   If both parameters are missing, the full input string is read. 
   If the parameter <right> is set to "-1", the string is read from <left>
   all the way to the end of the input string, independent of its length.

   The default values at program start are 1,-1 for all input channels.

!p Examples:  
!p   Input line: "A text string 20.0  30.0"
!p   fsub 14,24
!p   fget r[1],r[2]
3  functions

   The following intrinsic numerical functions exist:

!p asin(<arg>)                     !
!p acos(<arg>)                     !
!p atan(<arg>)                     !
!p atan(<arg1>,<arg2>)             ! Arguments are sine and cosine of angle
!p asind(<arg>)                    ! Result in degrees
!p acosd(<arg>)                    ! Result in degrees
!p atand(<arg>)                    ! Result in degrees
!p atand(<arg1>,<arg2>)            ! Arguments are sine and cosine of angle

!p sin(<arg>)                      !
!p cos(<arg>)                      !
!p tan(<arg>)                      !
!p sind(<arg>)                     ! Argument in degrees
!p cosd(<arg>)                     ! Argument in degrees
!p tand(<arg>)                     ! Argument in degrees

!p sinh(<arg>)                     ! Hyperbolic functions
!p cosh(<arg>)                     !
!p tanh(<arg>)                     !

!p sqrt(<arg>)                     ! Square root of <arg>
!p exp(<arg>)                      ! exponential (base e)
!p ln(<arg>)                       ! natural logarithm of <arg>
!p abs(<arg>)                      ! Absolute value of <arg>

!p mod(<arg1>,<arg2>)              ! Modulo <arg1> of <arg2>, real arguments
!p max(<arg1>,<arg2>)              ! Maximum of <arg1> and <arg2>
!p min(<arg1>,<arg2>)              ! Minimum of <arg1> and <arg2>

!p int(<arg>)                      ! Convert argument to integer
!p nint(<arg>)                     ! Convert argument to nearest integer
!p frac(<arg>)                     ! Returns fractional part of <arg>

!p ran(<arg>)                      ! Returns uniformly distributed pseudo
!p                                   random value 0<= r < 1.

!p gran(<arg>{,"s"|"f"})           ! Returns gaussian distributed pseudo
!p                                   random value with mean 0.0 and 
!p                                   sigma <arg> or FWHM <arg> if the 
!p                                   second argument is equal to "f". 

!p logn(<arg1>,<arg2>{,"s"|"f"})   ! Returns lognormal distributed pseudo
!p                                   random value. <arg1> is the location 
!p                                   of the most likely value. 
!p                                   <arg2> is the width of the distribution.
!p                                   More accurately, <arg2> is the width of 
!p                                   the underlying distribution ln(logn).
!p                                   It is either sigma <arg2> or FWHM <arg2> 
!p                                   if the third argument is equal to "f". 

!p pois(<arg>)                     ! Returns Poisson  distributed pseudo
!p                                   random value with mean <arg>.

   The arguments to any of these functions are any arithmetic expression.

   System functions:

!p date(0)                         ! Returns the current date as character
!p                                   string in the format:
!p                                   CCYYMMDDhhmmss.sss
!p                                   CCYY  : year    (century, year)
!p                                   MM    : month   (1,2,... 12)
!p                                   DD    : day     (1,2,... 31)
!p                                   hh    : hour    (1,2,... 24)
!p                                   mm    : minute  (1,2,... 60)
!p                                   ss.sss: second.milliseconds
!p                                   (g77: milliseconds are 000)
!p fdate(0)                        ! Returns the current date as character
!p                                   string in the format:
!p                                   Day Mon DD hh:mm:ss CCYY
!p                                   Day   : weekday (Mon, Tue,... Sun)
!p                                   Mon   : month   (Jan, Mar,... Dec)
!p                                   DD    : day     (1,2,... 31)
!p                                   hh    : hour    (1,2,... 24)
!p                                   mm    : minute  (1,2,... 60)
!p                                   ss    : second  (1,2,... 60)
!p                                   CCYY  : year    (century, year)
!p fmodt(0)                        ! Returns modification data and time
!p                                 ! of the file opened last. The format
!p                                 ! is the same as for fdate(0)
!p getcwd(0)                       ! Returns the current directory as
!p                                   character string
!p getenv('name')                  ! Returns the value of the environment
!p                                   variable <name>
3  help
!b help [<command> [, <subcommand>] ]

   The 'help' command is used to display on-line help messages. They are
   short notes on the command <command>. The command may be abbreviated.
   If the abbreviation is not unique, only the first help topic that matches
   the command is listed.

   The first line of the help text gives the syntax of the command that is
   explained in the following lines. For a few commands the syntax line is
   repeated for different set of possible parameters.

   After the text is displayed, you are in the HELP sublevel of PROG
   and there are the following commands possible:

!p <command> : Display help for <command> of current help level.
!p ".."      : Go up one help level.
!p "?"       : Prints list of help entries of the current level.
!p <RETURN>  : Exit help sublevel.
3  if
   The if-control structure takes the following form:

!p if ( <logical expression> ) then
!p   <conditional commands>
!p [elseif ( <logical expression>) then
!p   <conditional commands>]
!p [else
!p   <conditional commands>]
!p endif

   The logical expressions may contain numerical comparisons with syntax:

!p <arithmetic expression> <operator> <arithmetic comparison>

   The following operators are allowed:

!p .lt.    ! less than
!p .le.    ! less or equal
!p .gt.    ! greater than
!p .ge.    ! greater or equal
!p .eq.    ! equal
!p .ne.    ! not equal

   The logical expressions may also contain string comparisons with syntax:

!p '<string1>' <operator> '<string2>'

   Both strings MUST be enclosed by single apostrophes '. The operators
   are the same as those for the numeric expressions, lexical comparisons
   are used to evaluate the comparisons "less" and "greater".
   Within the single apostrophes you can place a character replacement 
   operation. Thus a valid example would be:
   variable character, line
   line='text'
   if( '"%c",line' .eq. 'text' ) then

   Logical expressions can be combined by logical operators:

!p .not.   ! negation of the following expression
!p .and.   ! logical and
!p .eqv.   ! logical equivalent
!p .xor.   ! logical exclusive or
!p .or.    ! logical or

   Logical operations may be nested and grouped by brackets "(" and ")".
3  learn
!b learn [<name>]

   Starts a learn sequence. All following commands are saved as typed
   in file <name>. defaults to "<prog>.mac". ==> lend finishes the
   learn sequence.
3  lend
!b lend

   Finishes the learn sequence started by ==> learn.
2  seed
!b seed [ <value> ]

   Reinitializes the pseudo random generator. The seed passed to the
   random generator is -abs(nint(value)). If the <value> is omitted,
   the random generator will be passed the number of hundredth of
   seconds passed since midnight, essentially initializing the sequence
   at a unknown fairly random point.
3  set
!b set <command>,..

   This command allows to alter various program independent setting.
   Allowed values for <command> are:

4  prompt
!b set prompt, {"on"|"off"|"redirect"},[{"on"|"off"|"file"}, ["save"]]
!b set prompt, "old"

   First parameter sets the status of the PROG prompt. The default is 
   "on", i.e. PROG prompts for the next command by writing "discus > "
   (in case you run DISCUS ..). You can turn this prompt off. This is 
   useful, if you are running a long macro and do not
   want to get all the prompts written into the output. By using this
   option you can considerably shorten the output written by PROG into a
   redirected log file. If you are using PROG on a UNIX platform, you can
   start the program with redirected input by the command:

!p "prog < inputfile"

   By default, PROG will write the prompt "discus >" into the output file,
   expecting a RETURN from the keyboard. Very long lines in the output file
   will result. To avoid this situation insert the line "set output,redirect"
   as first line in the inputfile to force discus to echo the lines from file
   inputfile.

   The prompt setting "redirect" has an important side effect on macro 
   treatment. With the "redirect" setting, macros are stored internally,
   once they have been read from disk, and will be reused from memory. This
   helps to reduce unnecessary I/O, especially when you have nested macros
   inside loops. For all other settings, the internal macro storage is 
   cleared when you get back to the normal interactive mode. This allows
   you to run a macro, then modify the version stored on the disk and 
   execute the modified/corrected version.

   This second parameter  allows the user to assign where the text output
   of the program should go: "on" prints on the screen, "off" will result 
   in no output and "file" will save the output to a file progname.log 
   (e.g. discus.log in DISCUS). Note that the output of the commands
   'echo' and 'eval' will always appear on the screen. The last parameter
   allows on to save the current prompt and output settings.

   The parameter "old" allow the user to and restore the setting of the 
   prompt and output. This can e.g. be used to turn the prompt off in a 
   macro and then restore the original setting after the macro is executed.
4  error
!b set error , {"cont" | "exit" | "live" }

   Sets the error status.

!p "cont"  PROG returns the normal prompt after the display of the error
!p         message. You can continue the input of commands.
!p         The execution of a macro file is stopped, the program continues
!p         with the regular prompt of the menu/submenu where the error occurred.
!p "exit"  PROG terminates after the display of the error message.
!p         This option is useful if you run PROG in the batch mode of your
!p         operating system. Instead of continuing with a faulty calculation
!p         PROG stops and you can immediately check the error.
!p "live"  PROG remains alive after an error is encountered. The variable
!p         "res[0]" is set to -1. The error number is written into "res[1]",
!p         the error type to "res[2]". Further error codes are written into
!p         "res[3]".
!p         With this error status, the program remains alive within a loop
!p         as well, which it does not do with the error status "cont".
!p         The program also continue to execute a macro! 
!p         It is most helpful to catch errors from the 'system' command
!p         and to allow a flexible response. 
4  debug
!b set debug, {"on" | "off"}

   This command allows the user to enable various DEBUG outputs ...
3  show
!b show {"res" | "variables"}

   The show command displays settings onto your screen. The individual
   programs discus, kuplot, diffev, mixscat all have specific parameters
   to the show command as well, see the help at the main program level
   for details.

!p "res"

   Many commands produce results that are stored in the result variable 
   res[<i>]. Thise are displayed via "show res".
   The entry res[0] gives the number of entries in the result variable.

!p "variables"

   Lists the variables that have been defined, their type and their 
   current values. The command is identical to the "variable show" 
   command.   
3  sleep
!b sleep <seconds>

   This command causes the program to sleep for <seconds> seconds
3  socket
!b socket "open",<host>,<port>
!b socket "close"
!b socket "exit"
!b socket "send",<string>
!b socket <string>
!b socket "transfer",<slave_var>,<expression>
!b socket "transfer",<slave_var>,<character expression>,<local_var>

   These commands connect to a program that has been started with the 
   "-remote" option, sees ==> "Options" for further help. 
   The commands will be send to the slave program where they will be
   executed as typed. 

4  open
!b socket "open",<host>,<port>

   Opens the connection to the program running on host <host> and 
   listening on port <port>. The server program  must have been 
   started beforehand with the "-remote" option
4  close
!b socket close

   Temporarily closes the connection to the slave program, which keeps
   running. You can open to the same program with a new socket open,<pname>.
4  exit
!b socket exit

   Terminates the slave program and closes the connection. To communicate
   with the slave program again, you must first start this with the
   "-remote" option and then open the connection with 
   socket "open",<pname>.
4  send
!b socket send,<string>
!b socket <string>

   The string is send to the slave program and executed as typed.
   Both forms are equivalent.
4  transfer
!b socket transfer,<slave_var>,<expression>
!b socket transfer,<slave_var>,<character expression>,<local_var>

   This command transverse the value of <expression> to the slave
   variable <slave_var>. You must define this slave variable prior
   to a transfer. 
4  Example

!p system /usr/local/bin/kuplot -remote   ! starts kuplot slave
!p i[0] = 4.0                             ! set local variable
!p socket open,localhost,3331             ! open connection
!p socket func r[0]**2,-2,2,0.1           ! define a function to plot
!p socket transfer,i[1],i[0]              ! transfer local variable
!p socket tit1 "%d",i[1]                  ! set plot title
!p socket plot                            ! display plot
!p socket mark 1,1                        ! change marker interval
!p socket plot                            ! plot again
!p socket send, mark 0.5,0.5              ! change marker interval
!p socket send, plot                      ! plot again
!p socket exit                            ! terminate kuplot, exit
3  stop
!b stop

   This command is active only while reading from a macro file or in
   interactive mode inside a block structure (do-loops and/or if's).

   The current macro file is interrupted and you can type commands as in the
   normal input mode. You can use the whole range of PROG commands,
   including the '@' macro command. The 'stop' commands provides a convenient
   mode to debug a macro by setting a break point at which you can check the
   value of variables or set new values, run an additional macro etc.

   To continue execution of the macro or to continue with the normal
   PROG mode, use the ==> 'continue' command.

   If included in a block structure statement (do-loops and/or if's) in
   both, macro and interactive mode, the program continues reading all
   statements that belong to the block structure. During execution of the
   structure, PROG interrupts this execution if it encounters a 'stop'
   command. You can issue any PROG command except further do or if commands.

   To continue execution of the structure or to continue with the normal
   PROG mode, use the ==> 'continue' command.
3  system
!b system <com>
!b system "string%dstring",<integer expression>
!b system "string%fstring",<float expression>

   Executes the single shell command <com>.
   If the command string is enclosed in "", you can place integer and
   real format specifiers "%d" "%f" which are then substituted by the
   corresponding values.

   Example
   i[0]=10
   system "ls %d.*"

   This would list all files called 10.*
3  wait
!b wait [{"return" | "input" [,<prompt>] }]

   This command waits for user input. 
   Without a parameter or with "return", the program waits for a 
   simple <RETURN>.
   If the first parameter is "input", the program expects the user to enter
   one or more real numbers or expressions. The optional <prompt> can be 
   used to ask the user to input the expressions. This is especially 
   helpful if the prompt has been turned of by ==> set prompt,off.
   The number of expressions entered by the user is stored in the variable
   res[0] and the results of the expressions in res[i].

   This command allows to write interactive macros, demo macros
   and tutorials.
3  variable
!p variable {"integer"|"real"},<name> [,<initial_value>]
!p variable {"character"},<name>
!p variable show

   The programs that are part of the DIFFUSE suite offer predefined
   variables i[*] and r[*]. These are an integer and a real 
   array, respectively, into whose element you may store appropriate
   values. 
   In order to enhance readability of a macro, you can define your
   own variable names by the use of this command. The variable may
   either be an integer or a real variable. There is no predefined
   syntax for the variable names. Optionally you can initialize the
   variable to <initial_value>, default is zero. These user defined
   variables may be used just as the system integer and real 
   variables i[*] and r[*]. 
   Character variables may be used to hold a string of text.

   The variable names may only consist of alphanumerical characters
   including the underscore "_".
   Presently they are single value variables.

   If the first command parameter is "show" the program displays a
   list of user defined variables and their current values.
   Refer to the help entry "expressions" for further help.

   Examples:
!p variable  int,alpha,90
!p variable  int,beta
!p variable  real,diff
!p beta = 94
!p diff = alpha - beta
!p eval diff

!p variable  character,string
!p variable  character,line
!p string = "abcdefg"
!p line   = "%3c",string(2:4)
!p var show

   Variable names that are part of intrinsic functions, keywords like
   "do", "elseif", "eq", and program specific variables like "r" and "i" 
   are not allowed. Thus a variable called "a" is illegal, since it
   is part of the intrinsic function "asin".

   Internally the program sorts the variable names by length and in
   inverse alphabetical order. This sorting has no serious consequence
   for the user other than finding the variable in the printed list
   when using the 'variable show' command. 
3  errors

   The program has been written such that it should handle almost
   any typing error when giving commands and hopefully all errors
   that result from calculation with erroneous data. When an error
   is found an error message is displayed that should get you back
   on track. See the manual for a complete list of error messages.
   In this part we refer to the program you are using as DISCUS for
   convenience.

   The error messages concerning the use of the command language
   are grouped in the following categories:

!p COMM   Command language errors
!p FORT   Fortran interpreter errors
!p I/O    Errors regarding input/output
!p MACR   Errors related to macros
!p MATH   General mathematical errors

   Each error message is displayed together with the corresponding
   category <cccc> and the error number <numb> in the form:

!p ****CCCC****message                    **** numb ****

   In the default mode DISCUS returns the standard prompt and you can 
   continue the execution from this point. You can set the error status
   to "exit" by the ==>'set' command. In this case DISCUS terminates 
   if an error is detected. This option is useful to terminate a faulty
   sequence of commands when running DISCUS in the batch mode of your
   operating system.

4  comm

   Command language errors
   These messages describe illegal usage of the command language, such as
   unknown commands, improper numbers of parameters.

5  -1
   DISCUS directory not defined

   The environment variable DISCUS_DIR was not defined. Check the chapter 
   on installation for your platform for the appropriate definition. 
5  -2
   Command parameter has zero length

   On the command line you probably have a typing error like two 
   comma following each other without significant values in between, 
   or the first non blank character after the command is a comma.
5  -3
   Could not allocate arrays

   The program has to allocate arrays, but received a error message.
   Does your computer have enough available memory space?
5  -5
   Error in operating system command

   The operating system/shell returned an error message. Check the 
   appropriate system manuals for details. 
5  -6
   Missing or wrong parameters for command

   Either the command needs more parameters than were provided, or the 
   parameters are incorrect. Check the number and type of parameters. Is 
   the sequence of numerical and character parameters correct? 
5  -8
   Unknown command

   The command interpreter read an unknown command. Check the spelling 
   of the command or check, whether this command is allowed at the current
   sublevel. 
5  -11
   Error in subroutine

   More or less a system error message, ignore this message. 
5  -17
   Too many parameters

   More parameters have been provided than are required by the command. 
   Check the number, and type of parameters supplied, or the occurrence 
   of additional ','. 
4  fort

   Fortran interpreter errors
   These messages describe erroneous mathematical calculations and
   improper usage of control structures (do,if, ...).

5  -1
   Nonnumerical Parameters in expression

   The interpreter found a nonnumerical string where a number is expected. 
   If an intrinsic function or a variable was intended, check for spelling
   or missing parentheses. 
5  -2
   Unknown Variable

   The expression contains a reference to an unknown variable. Check the 
   spelling of the variable. Chapter 3.7.1 of the manual and the help
   entry "variables" contains a list of allowed variables. 
   Check whether the variable is a read-only variable and was used on the 
   left side of an expression. Some of the variables associated with
   microdomains are read-only depending of the circumstances! 
5  -3
   Unknown intrinsic function

   The expression contains a reference to an unknown intrinsic function. 
   Check the spelling of the function. Chapter 3.7.4 of the general part
   in the manual and the help entry "functions' contain a complete list
   of the allowed intrinsic functions. 
5  -4
   Division by zero'

   An attempt was made to divide by zero. Check the value of the argument 
   and correct the algorithm that calculates the argument. 
5  -5
   Square root of negative number

   An attempt was made to calculate the square root of a negative argument. 
   Check the value of the argument and correct the algorithm that calculates 
   the argument. 
5  -6
   Missing or wrong Parameters for command

   Either the function or variable referenced needs more parameters than 
   were provided, or the parameters are incorrect. Check the number and 
   type of parameters. Is the sequence of numerical and character parameters 
   correct? 
5  -7
   Argument for asin,acos greater 1

   An attempt was made to calculate asin or acos with an argument greater 
   than 1. Check the value of the argument and correct the algorithm 
   that calculates the argument. 
5  -8
   Index outside array limits

   The index supplied for the variable is outside the limits of this
   variable. Check the general part for the dimensions of the variables. 
5  -9
   Number of brackets is not matching

   The number of opening and closing brackets "[" and "]" does not match
   or is illegally nested with parentheses "(", ")" or other operators.
   Check the string used in the expression and correct it following the
   FORTRAN rules.
5  -10
   Index for array element is missing

   You have used a string like "i[]", where the opening and closing 
   brackets do not contain any expression.
   Check the string used in the expression and correct it following the
   FORTRAN rules.
5  -11
   Number of parentheses is not matching

   The number of opening and closing parentheses "(" and ")" does not match
   or is illegally nested with brackets "[", "]" or other operators.
   Check the string used in the expression and correct it following the
   FORTRAN rules.
5  -12
   Expression between () is missing

   You have used a string like "()", where the opening and closing 
   parentheses "(" and ")" do not contain any expression.
   Check the string used in the expression and correct it following the
   FORTRAN rules.
5  -13
   Wrong number of indices for array

   The number of indices given for the entered parameter is wrong.
   Check the help entry 'variables' for the proper number of indices.
5  -14
   Index of DO-loop counter is missing

   Here the index for the loop counter of a do-loop is missing. Check
   the online help for the correct syntax of such loops.
5  -15
   Too many commands

   The program stores all commands within a control block in an array. 
   The maximum number of commands that can be stored in this array is 
   given by the parameter MAXCOM in file "doloop.inc". The macro or run
   used more commands than currently allowed by this parameter. 
   Rewrite the macro or list of commands such that less commands are 
   sufficient, or change the value of the parameter and recompile the 
   program. 
5  -16
   Too deeply leveled (do,if) construction

   The program stores all commands within a control block in an array. 
   The maximum number of levels for this array is given by the parameter 
   MAXLEV in file "doloop.inc". The macro or run used more levels than 
   currently allowed by this parameter. 
   Rewrite the macro or list of commands such that less levels are 
   sufficient, or change the value of the parameter and recompile the 
   program. 
5  -18
   Unresolvable condition

   An error occurred while trying to calculate the value of an arithmetic 
   or logical expression. Check that there is no illegal operation /(division 
   by zero .../ no typing errors, all parentheses are properly matched. 
5  -19
   Illegal nesting of control commands

   Do  loops and/or if constructions have been nested with overlapping 
   segments, missing enddo or endif statements or similar causes. Check 
   for spelling errors on the control statements, and that each control 
   statement is properly terminated by a corresponding enddo or endif 
   statement that is not enclosed within another control block. 
5  -20
   Illegal argument for ln(x) function

   The argument for the ln must be positive, larger than zero. Check the
   value of the argument or the value of the expression that serves as 
   argument
5  -21
   Missing ' while comparing stings

   An expression of the form ('string' .eq. 'line') was used, where
   one of the quotation marks has been omitted. Check the respective
   line.
5  -22
   Maximum number of real variables defined

   DISCUS can define a fixed number of user variable names. The maximum
   number allowed for your installation id displayed by the command
   variable show
   If you would like more user definable variable names, change
   the value of the parameter VAR_REAL_MAX in "config.inc"
5  -23
   Maximum number of int. variables defined

   DISCUS can define a fixed number of user variable names. The maximum
   number allowed for your installation id displayed by the command
   variable show
   If you would like more user definable variable names, change
   the value of the parameter VAR_INTE_MAX in "config.inc"
5  -24
   Variable is not defined

   You tried to use a name within an expression that was not recognized
   as a user defined variable name. Check the spelling of the line.
   Was an intrinsic function to be used, or was the variable not
   defined? See the ==> 'variable' entry in the help menu regarding
   the definition of variables.
   You will also get this error message if you tried to define a 
   variable using the command:
   variable real,dummy=3
   The equal sign "=" may not be used as part of a variable name. If
   you intend to provide an initializing value, use the command as:
   variable real,dummy,3
5  -25
   Variable name contains illegal characters

   You tried to define a variable name that contains characters other
   than letters, numbers or the underscore "_".
   The variable names are restricted to alphanumerical characters and
   the underscore "_".
5  -26
   Variable name contains illegal characters

   Variable names may consist only of letters (lower and upper case),
   numbers and the underscore "_". Check the spelling of the variable
   you tried to define with respect to these rules.
5  -27
   Function with wrong number of arguments

   You called an intrinsic function with the wrong number of arguments.
   Check the listing of intrinsic functions for the valid number of
   arguments and the compare to the input line you had typed.
5  -28
   Too deeply leveled break command

   Illegal use of the break command. The parameter on the break command 
   signals how many block structure levels are to be exited. Check the 
   value of this parameter with regard to the nesting of do-loops and 
   if-blocks. 
5  -29
   Character substring out of bounds',        & !-29  ! fortran

   In a statement like 
   variable character, line
   line = 'abcde'
   echo "%c",line(1,5)
   The first index is  less than one, or the second index is larger than
   the number of characters in the strin, or the second index is less
   than the first.
5  -30
   Right quotation mark missing in format'

   A statement like 
   echo " text " 
   is missing the right quotation mark.
5  -31
   Incomplete (do,if) statement

   Some part of a ==> 'do' or ==> 'if' statement is missing.
   Check the line for missing part or typing errors. 
5  -32
   Variable name is already defined

   The variable that you want to define is already in use as another
   data type. 
5  -33
   Variable in use; cannot initialize value

   A variable name can be redifined as identical data type, in order 
   to be able to use a macro with a variable definition inside a loop.
   You may, however, not provide an initialisation value, as this would
   override the current value.
5  -34
   String has length zero',                   & !-34  ! fortran

   A statement like
   echo ""   or
   line = ''
   occured in which the single or doluble quotation marks enclose a 
   zero length string.
4  i/o

   Errors related to input / output
   An error occurred while attempting to read/write from a file

5  -1
   File does not exist

   DISCUS could not find the file. Check the spelling and the path. 
5  -2
   Error opening file

   DISCUS could not open a file. The file might be in use by another process. 
5  -3
   Error reading file

   An error occurred while  DISCUS was reading a file. Check whether the 
   contents of the file is correct. 
5  -4
   File already exists

   An attempt was made to overwrite an existing file. Rename or delete 
   the file in question. 
5  -5
   No such entry in online help

   You have tried to obtain help for a string that does not have a matching
   entry in the help file. 

   Check the spelling of the string. Are you at the right sublevel?
   Use the '?' command to get a listing of available help entries.
5  -6
   Unexpected end of file

   DISCUS has encountered the end of a file, but is still expecting data.
   Check the file(s) involved, to see whether the data are complete or
   whether erroneous data are present.
5  -7
   Learning sequence already in progress

   You have tried to start a learning sequence by ==>'learn' without 
   closing the active learning sequence. Close the current learning
   sequence by ==> 'lend' before starting to record a new macro.
5  -8
   Nothing learned - no macro written

   You did not type any commands since the ==>'learn' command. No commands
   are written to the macro file.
   You need to give at least one command before closing a learn sequence.
5  -9
   Error reading user input

   An error occurred while reading the last input. 
   Does the string contain any characters where a number is expected, or
   any control or escape sequences.
5  -10
   IO stream already open

   The command 'fopen' was issued while there was already a file open.
   Close the currently open file with 'fclose'.
5  -11
   No IO stream open to close

   The command 'fclose' was issued, but there is no open file.
5  -12
   Error writing to file

   An error occurred when reading a file with 'fget'. Check the file
   for nonnumerical values and check that the number of columns is
   equal or larger than the number of arguments of 'fget'.  

5  -13
   I/O stream number outside valid range

   The I/O stream number must be larger than 0 and less than the value
   defined in macro.inc, which usually is 10.

5  -14
   Filename has zero length

   You tried to open a file with ==> 'fopen', whose file name is of
   length zero.
   Check the statement for the missing filename, or an additional comma.
5  -15
   No socket connected

   Apparently you tried to use a ==> 'socket' command prior to opening
   a connection to the remote computer. 
   Use a 'socket open' command first.
5  -16
   Could not resolve hostname for socket

   The hostname to which you want to connect could not be resolved into
   an IP address. 
   Check the host name for typing errors and the Internet access of your
   computer.
5  -17
   Could not grab socket

   Internal socket debug message.
5  -18
   Could not open socket connection

   Internal socket debug message.
5  -19
   Problem sending to socket

   Internal socket debug message.
5  -20
   Problem receiving from socket

   Internal socket debug message.
5  -21
   Received null string from socket receive

   The remote computer send back an answer of zero length. Apparently 
   the connection was terminated prematurely.

   Try to connect again.
5  -22
   Socket accept problem

   Internal socket debug message.
5  -23
   Scocket: Rejected connection

   Internal socket debug message.
5  -24
   Socket bind problem

   Internal socket debug message.
5  -25
   Socket listen problem

   Internal socket debug message.
5  -26
   Second parameter must be >= first Param.

   You tried to read a substring with a line like
   echo "%c",line(1:5)
   but the second parameter , here a "5" was less than the first, here a "1".
   The second parameter must be equal to or larger than the first in order 
   to specify a valid substring.
4  macro

   Errors related to macro
   These messages describe situations that result from missing macrofiles,
   missing macro parameters ...

5  -1
   Too many macro parameters given

   The number of parameters given on the macro command line is higher
   than allowed in your installation. The maximum number of parameters
   allowed is defined by the parameter MAC_MAX_PARA in the file 
   macro.inc.
   Check the macro command line for any additional "," or rewrite the
   macro to use less parameters. If necessary adjust the value of the
   parameter MAC_MAX_PARA and recompile the program.
5  -12
   Macro not found

   The file given on the @<name> command does not exist. Check the 
   spelling of <name> and the path.
5  -13
   Macro filename is missing on the command line

   The command '@' to execute a macro was called without any macro 
   file name. The file name must start immediately after the "@".
   Check the '@' command for completeness and blanks after the "@".
5  -35
   Too deeply leveled macros

   The maximum level at which macros may be nested is defined in the 
   file macro.inc in the parameter MAC_MAX_LEVEL. Check the nesting of 
   macro file for the level of nesting or possible recursive nesting
   without proper termination. Rewrite the macros to use less nesting,
   or change the value of the parameter and recompile the program. 
5  -36
   Unexpected EOF in macro file

   When DISCUS finds a '@' command inside a macro, it stores the current 
   macro name, the line number inside the current macro and closes the 
   current macro file. After completion of the new macro, the previous 
   macro is read again up to the position stored. The error message 
   is displayed when an end of file is found before the position is 
   reached. Check whether the macro file was damaged, or accidentally 
   deleted during execution of the nested macro. 
5  -41
   Not enough macro parameters given

   DISCUS read a parameter number inside a macro file that is higher
   than the number of parameters given on the command line of the macro.
   Check the parameters inside the macro for correct numbering and
   spelling. Check the number of parameters supplied on the command and
   check whether any "," is missing between parameters. 
